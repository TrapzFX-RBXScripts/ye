local REALGAME = game

local changemode = Instance.new("Sound", owner.Character.Torso)
changemode.SoundId = "rbxassetid://847061203"

mas = owner.Character
Model0 = Instance.new("Model")
Part1 = Instance.new("Part")
Part2 = Instance.new("Part")
SpecialMesh3 = Instance.new("SpecialMesh")
Weld4 = Instance.new("Weld")
Model5 = Instance.new("Model")
Part6 = Instance.new("Part")
SpecialMesh7 = Instance.new("SpecialMesh")
Part8 = Instance.new("Part")
SpecialMesh9 = Instance.new("SpecialMesh")
Part10 = Instance.new("Part")
SpecialMesh11 = Instance.new("SpecialMesh")
Part12 = Instance.new("Part")
Weld13 = Instance.new("Weld")
Weld14 = Instance.new("Weld")
Weld15 = Instance.new("Weld")
Weld16 = Instance.new("Weld")
Weld17 = Instance.new("Weld")
Part18 = Instance.new("Part")
SpecialMesh19 = Instance.new("SpecialMesh")
Model0.Name = "wingmodel"
Model0.Parent = mas
Part1.Name = "WeldPoint"
Part1.Parent = Model0
Part1.CFrame = CFrame.new(-81.4001617, 3.0001092, -59.4999657, 4.64916684e-06, -6.76512991e-06, 1.00000906, 6.28828411e-06, -0.999996006, -6.3627931e-06, 1.00000262, 6.76513309e-06, 1.16229512e-06)
Part1.Orientation = Vector3.new(0, 90, 180)
Part1.Position = Vector3.new(-81.400161743164, 3.0001091957092, -59.499965667725)
Part1.Rotation = Vector3.new(180, 90, 0)
Part1.Transparency = 1
Part1.Size = Vector3.new(0.13594952225685, 0.033987414091825, 0.13594956696033)
Part1.BottomSurface = Enum.SurfaceType.Smooth
Part1.CanCollide = false
Part1.TopSurface = Enum.SurfaceType.Smooth
Part2.Name = "ring"
Part2.Parent = Model0
Part2.CFrame = CFrame.new(-78.8000031, 4.5, -59.5, 0, 1, 0, -1, 0, 0, 0, 0, 1)
Part2.Orientation = Vector3.new(0, 0, -90)
Part2.Position = Vector3.new(-78.800003051758, 4.5, -59.5)
Part2.Rotation = Vector3.new(0, 0, -90)
Part2.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part2.Size = Vector3.new(4, 0.60000002384186, 2)
Part2.BottomSurface = Enum.SurfaceType.Smooth
Part2.BrickColor = BrickColor.new("Bright blue")
Part2.CanCollide = false
Part2.Material = Enum.Material.Neon
Part2.TopSurface = Enum.SurfaceType.Smooth
Part2.brickColor = BrickColor.new("Bright blue")
SpecialMesh3.Parent = Part2
SpecialMesh3.MeshId = "rbxassetid://2935658182"
SpecialMesh3.Scale = Vector3.new(1, 0.60000002384186, 1)
SpecialMesh3.MeshType = Enum.MeshType.FileMesh
Weld4.Name = "WeldPoint"
Weld4.Parent = Part2
Weld4.C0 = CFrame.new(1.4998908, -2.60015869, 3.43322754e-05, -6.28828411e-06, 0.999996006, 6.3627931e-06, 4.64916684e-06, -6.76512991e-06, 1.00000906, 1.00000262, 6.76513309e-06, 1.16229512e-06)
Weld4.Part0 = Part2
Weld4.Part1 = Part1
Weld4.part1 = Part1
Model5.Name = "wings"
Model5.Parent = Model0
local wpfold = Instance.new("Folder", Model5)
Part6.Name = "WP1"
Part6.Parent = wpfold
Part6.CFrame = CFrame.new(-77.8319855, 4.47729301, -61.5564995, 1.00001812, 5.65818073e-06, -2.68971121e-06, -1.88511365e-06, 4.86264253e-06, -0.999992013, 5.96471773e-06, 1.00000525, 5.81633503e-06)
Part6.Orientation = Vector3.new(89.769996643066, -24.819999694824, -21.190000534058)
Part6.Position = Vector3.new(-77.831985473633, 4.4772930145264, -61.556499481201)
Part6.Rotation = Vector3.new(90, 0, 0)
Part6.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part6.Size = Vector3.new(0.82142871618271, 0.49285724759102, 1.1500002145767)
Part6.BottomSurface = Enum.SurfaceType.Smooth
Part6.BrickColor = BrickColor.new("Bright blue")
Part6.CanCollide = false
Part6.Material = Enum.Material.Neon
Part6.TopSurface = Enum.SurfaceType.Smooth
Part6.brickColor = BrickColor.new("Bright blue")
SpecialMesh7.Parent = Part6
SpecialMesh7.MeshId = "rbxassetid://6542084887"
SpecialMesh7.Scale = Vector3.new(0.20535717904568, 0.49285724759102, 0.57500010728836)
SpecialMesh7.MeshType = Enum.MeshType.FileMesh
Part8.Name = "WP1"
Part8.Parent = wpfold
Part8.CFrame = CFrame.new(-77.8319855, 4.47728825, -57.4493408, 1.00001812, 5.65801929e-06, -2.68956455e-06, 3.4940781e-06, -4.86263252e-06, 0.999992013, 1.72807431e-05, -1.00000525, -5.8163987e-06)
Part8.Orientation = Vector3.new(-89.769996643066, -155.17999267578, 144.30000305176)
Part8.Position = Vector3.new(-77.831985473633, 4.4772882461548, -57.449340820313)
Part8.Rotation = Vector3.new(-90, 0, 0)
Part8.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part8.Size = Vector3.new(0.82142871618271, 0.49285724759102, 1.1500002145767)
Part8.BottomSurface = Enum.SurfaceType.Smooth
Part8.BrickColor = BrickColor.new("Bright blue")
Part8.CanCollide = false
Part8.Material = Enum.Material.Neon
Part8.TopSurface = Enum.SurfaceType.Smooth
Part8.brickColor = BrickColor.new("Bright blue")
SpecialMesh9.Parent = Part8
SpecialMesh9.MeshId = "rbxassetid://6542084887"
SpecialMesh9.Scale = Vector3.new(0.20535717904568, 0.49285724759102, 0.57500010728836)
SpecialMesh9.MeshType = Enum.MeshType.FileMesh
Part10.Name = "WP1"
Part10.Parent = wpfold
Part10.CFrame = CFrame.new(-77.8319702, 6.53084278, -59.5029221, 1.00001812, 5.65802793e-06, -2.68971962e-06, 6.46242324e-06, -0.999992013, -4.86265344e-06, 8.93309516e-06, 5.81641825e-06, -1.00000525)
Part10.Orientation = Vector3.new(0, -180, 180)
Part10.Position = Vector3.new(-77.831970214844, 6.5308427810669, -59.502922058105)
Part10.Rotation = Vector3.new(180, 0, 0)
Part10.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part10.Size = Vector3.new(0.82142871618271, 0.49285724759102, 1.1500002145767)
Part10.BottomSurface = Enum.SurfaceType.Smooth
Part10.BrickColor = BrickColor.new("Bright blue")
Part10.CanCollide = false
Part10.Material = Enum.Material.Neon
Part10.TopSurface = Enum.SurfaceType.Smooth
Part10.brickColor = BrickColor.new("Bright blue")
SpecialMesh11.Parent = Part10
SpecialMesh11.MeshId = "rbxassetid://6542084887"
SpecialMesh11.Scale = Vector3.new(0.20535717904568, 0.49285724759102, 0.57500010728836)
SpecialMesh11.MeshType = Enum.MeshType.FileMesh
Part12.Name = "SP"
Part12.Parent = Model5
Part12.CFrame = CFrame.new(-77.8319855, 4.47729111, -59.5029182, 1.00001812, 5.65817936e-06, -2.68971007e-06, -1.88511467e-06, 4.86264435e-06, -0.999992013, 5.96471637e-06, 1.00000525, 5.81633321e-06)
Part12.Orientation = Vector3.new(89.769996643066, -24.819999694824, -21.190000534058)
Part12.Position = Vector3.new(-77.831985473633, 4.4772911071777, -59.502918243408)
Part12.Rotation = Vector3.new(90, 0, 0)
Part12.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part12.Transparency = 1
Part12.Size = Vector3.new(0.082142874598503, 0.082142874598503, 0.082142874598503)
Part12.BottomSurface = Enum.SurfaceType.Smooth
Part12.BrickColor = BrickColor.new("Bright blue")
Part12.CanCollide = false
Part12.Material = Enum.Material.Neon
Part12.TopSurface = Enum.SurfaceType.Smooth
Part12.brickColor = BrickColor.new("Bright blue")
Weld13.Name = "WP1"
Weld13.Parent = Part12
Weld13.C0 = CFrame.new(1.25340075e-05, -2.0535717, -1.17506324e-05, 1, 1.36424205e-12, -1.0769996e-12, 1.36424205e-12, 1, 1.8189894e-12, -1.07699266e-12, 1.8189894e-12, 1)
Weld13.Part0 = Part12
Weld13.Part1 = Part6
Weld13.part1 = Part6
Weld14.Name = "WP1"
Weld14.Parent = Part12
Weld14.C0 = CFrame.new(-1.25340075e-05, 2.0535655, 1.2925695e-05, 1, 1.1315994e-05, -5.37917731e-06, 1.13159986e-05, -1, -3.31965566e-11, -5.37918049e-06, -3.31965566e-11, -1)
Weld14.Part0 = Part12
Weld14.Part1 = Part8
Weld14.part1 = Part8
Weld15.Name = "WP1"
Weld15.Parent = Part12
Weld15.C0 = CFrame.new(6.26700376e-06, 6.26700376e-06, -2.05356836, 1, 8.34758703e-06, 2.96840585e-06, 2.96841154e-06, 3.54702934e-11, -1, -8.34758976e-06, 1, 3.63797881e-12)
Weld15.Part0 = Part12
Weld15.Part1 = Part10
Weld15.part1 = Part10
Weld16.Name = "WP1"
Weld16.Parent = Part12
Weld16.C0 = CFrame.new(6.26700376e-06, -6.26700376e-06, 2.05357075, 1, 2.96841108e-06, -8.3475843e-06, 8.34759066e-06, 2.77395884e-11, 1, 2.96840653e-06, -1, 1.13686838e-11)
Weld16.Part0 = Part12
Weld16.Part1 = Part18
Weld16.part1 = Part18
Weld17.Name = "WeldPoint"
Weld17.Parent = Part12
Weld17.C0 = CFrame.new(-3.5681076, 0.00296401978, 1.47720003, 4.80242852e-06, -4.47772391e-06, 1.00000906, 1.00000262, 1.42565523e-06, 1.00900081e-06, -9.48775323e-07, 0.999996006, 4.07536072e-06)
Weld17.Part0 = Part12
Weld17.Part1 = Part1
Weld17.part1 = Part1
Part18.Name = "WP1"
Part18.Parent = wpfold
Part18.CFrame = CFrame.new(-77.8319855, 2.42373681, -59.5029144, 1.00001812, 5.65817481e-06, -2.68955591e-06, -4.85345709e-06, 0.999992013, 4.86264889e-06, 1.4312368e-05, -5.81628774e-06, 1.00000525)
Part18.Position = Vector3.new(-77.831985473633, 2.4237368106842, -59.502914428711)
Part18.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part18.Size = Vector3.new(0.82142871618271, 0.49285724759102, 1.1500002145767)
Part18.BottomSurface = Enum.SurfaceType.Smooth
Part18.BrickColor = BrickColor.new("Bright blue")
Part18.CanCollide = false
Part18.Material = Enum.Material.Neon
Part18.TopSurface = Enum.SurfaceType.Smooth
Part18.brickColor = BrickColor.new("Bright blue")
SpecialMesh19.Parent = Part18
SpecialMesh19.MeshId = "rbxassetid://6542084887"
SpecialMesh19.Scale = Vector3.new(0.20535717904568, 0.49285724759102, 0.57500010728836)
SpecialMesh19.MeshType = Enum.MeshType.FileMesh

local e = Vector3.new(0,180,0)
--spin
spawn(function()
	while true do
		Part12.CFrame = Part12.CFrame * CFrame.fromEulerAnglesXYZ(0,0.05,0)
		wait()
	end
end)

spawn(function()
	Part1.CFrame = owner.Character.Torso.CFrame
	local weld = Instance.new("Weld")
	Part1.Orientation = Part1.Orientation - Vector3.new(0,0,180)
	weld.Parent = Part1
	weld.Part0 = Part1
	weld.C0 = owner.Character.Torso.CFrame:ToObjectSpace(Part1.CFrame)
	weld.Part1 = owner.Character.Torso
end)

--Converted with ttyyuu12345's model to script plugin v4
function sandbox(var,func)
	local env = getfenv(func)
	local newenv = setmetatable({},{
		__index = function(self,k)
			if k=="script" then
				return var
			else
				return env[k]
			end
		end,
	})
	setfenv(func,newenv)
	return func
end
cors = {}
mas = Instance.new("Model",game:GetService("Lighting"))
Folder0 = Instance.new("Folder")
MeshPart1 = Instance.new("MeshPart")
MeshPart2 = Instance.new("MeshPart")
MeshPart3 = Instance.new("MeshPart")
MeshPart4 = Instance.new("MeshPart")
MeshPart5 = Instance.new("MeshPart")
MeshPart6 = Instance.new("MeshPart")
MeshPart7 = Instance.new("MeshPart")
MeshPart8 = Instance.new("MeshPart")
MeshPart9 = Instance.new("MeshPart")
MeshPart10 = Instance.new("MeshPart")
MeshPart11 = Instance.new("MeshPart")
ParticleEmitter12 = Instance.new("ParticleEmitter")
ParticleEmitter13 = Instance.new("ParticleEmitter")
Model14 = Instance.new("Model")
UnionOperation15 = Instance.new("UnionOperation")
UnionOperation16 = Instance.new("UnionOperation")
UnionOperation17 = Instance.new("UnionOperation")
UnionOperation18 = Instance.new("UnionOperation")
UnionOperation19 = Instance.new("UnionOperation")
UnionOperation20 = Instance.new("UnionOperation")
UnionOperation21 = Instance.new("UnionOperation")
UnionOperation22 = Instance.new("UnionOperation")
Part23 = Instance.new("Part")
Model24 = Instance.new("Model")
Model25 = Instance.new("Model")
Part26 = Instance.new("Part")
Decal27 = Instance.new("Decal")
SpecialMesh28 = Instance.new("SpecialMesh")
UnionOperation29 = Instance.new("UnionOperation")
Model30 = Instance.new("Model")
Part31 = Instance.new("Part")
UnionOperation32 = Instance.new("UnionOperation")
UnionOperation33 = Instance.new("UnionOperation")
UnionOperation34 = Instance.new("UnionOperation")
MeshPart35 = Instance.new("MeshPart")
Part36 = Instance.new("Part")
ParticleEmitter37 = Instance.new("ParticleEmitter")
Folder0.Name = "Effects"
Folder0.Parent = mas
MeshPart1.Name = "Ring"
MeshPart1.Parent = Folder0
MeshPart1.CFrame = CFrame.new(-46.9483795, 116.464165, 24.7738743, 0, 1, 0, 0, 0, -1, -1, 0, 0)
MeshPart1.Orientation = Vector3.new(90, 90, 0)
MeshPart1.Position = Vector3.new(-46.948379516602, 116.46416473389, 24.773874282837)
MeshPart1.Rotation = Vector3.new(90, 0, -90)
MeshPart1.Color = Color3.new(0.972549, 0.972549, 0.972549)
MeshPart1.Size = Vector3.new(18.000999450684, 18.001998901367, 2.0009999275208)
MeshPart1.Anchored = true
MeshPart1.BrickColor = BrickColor.new("Institutional white")
MeshPart1.CanCollide = false
MeshPart1.Material = Enum.Material.Neon
MeshPart1.brickColor = BrickColor.new("Institutional white")
MeshPart2.Name = "Slash"
MeshPart2.Parent = Folder0
MeshPart2.CFrame = CFrame.new(-37.9483795, 119.999924, 24.7738743, 0, 1, 0, 0, 0, -1, -1, 0, 0)
MeshPart2.Orientation = Vector3.new(90, 90, 0)
MeshPart2.Position = Vector3.new(-37.948379516602, 119.99992370605, 24.773874282837)
MeshPart2.Rotation = Vector3.new(90, 0, -90)
MeshPart2.Color = Color3.new(0.972549, 0.972549, 0.972549)
MeshPart2.Size = Vector3.new(188.98999023438, 20, 239)
MeshPart2.Anchored = true
MeshPart2.BrickColor = BrickColor.new("Institutional white")
MeshPart2.CanCollide = false
MeshPart2.Material = Enum.Material.Neon
MeshPart2.brickColor = BrickColor.new("Institutional white")
MeshPart3.Name = "Skull"
MeshPart3.Parent = Folder0
MeshPart3.CFrame = CFrame.new(-66.296875, 116.464165, 21.624012, 0, 1, 0, 0, 0, -1, -1, 0, 0)
MeshPart3.Orientation = Vector3.new(90, 90, 0)
MeshPart3.Position = Vector3.new(-66.296875, 116.46416473389, 21.624011993408)
MeshPart3.Rotation = Vector3.new(90, 0, -90)
MeshPart3.Color = Color3.new(0.972549, 0.972549, 0.972549)
MeshPart3.Size = Vector3.new(0.50249099731445, 0.43240550160408, 0.54364001750946)
MeshPart3.Anchored = true
MeshPart3.BrickColor = BrickColor.new("Institutional white")
MeshPart3.CanCollide = false
MeshPart3.Material = Enum.Material.Neon
MeshPart3.brickColor = BrickColor.new("Institutional white")
MeshPart4.Name = "Sword"
MeshPart4.Parent = Folder0
MeshPart4.CFrame = CFrame.new(-46.9483795, 116.464165, 24.7738743, 0, 1, 0, 0, 0, -1, -1, 0, 0)
MeshPart4.Orientation = Vector3.new(90, 90, 0)
MeshPart4.Position = Vector3.new(-46.948379516602, 116.46416473389, 24.773874282837)
MeshPart4.Rotation = Vector3.new(90, 0, -90)
MeshPart4.Color = Color3.new(0.972549, 0.972549, 0.972549)
MeshPart4.Size = Vector3.new(0.59923082590103, 2.3029749393463, 6.8251519203186)
MeshPart4.Anchored = true
MeshPart4.BrickColor = BrickColor.new("Institutional white")
MeshPart4.CanCollide = false
MeshPart4.Material = Enum.Material.Neon
MeshPart4.brickColor = BrickColor.new("Institutional white")
MeshPart5.Name = "Smash8"
MeshPart5.Parent = Folder0
MeshPart5.CFrame = CFrame.new(165.539078, 113.2938, 91.2830048, 1, 0, 0, 0, 1, 0, 0, 0, 1)
MeshPart5.Position = Vector3.new(165.53907775879, 113.293800354, 91.283004760742)
MeshPart5.Color = Color3.new(0.972549, 0.972549, 0.972549)
MeshPart5.Size = Vector3.new(3.0020718574524, 0.50447261333466, 3.000883102417)
MeshPart5.Anchored = true
MeshPart5.BrickColor = BrickColor.new("Institutional white")
MeshPart5.CanCollide = false
MeshPart5.Material = Enum.Material.Neon
MeshPart5.brickColor = BrickColor.new("Institutional white")
MeshPart6.Name = "Smash6"
MeshPart6.Parent = Folder0
MeshPart6.CFrame = CFrame.new(168.257599, 113.2938, 91.5336838, 1, 0, 0, 0, 1, 0, 0, 0, 1)
MeshPart6.Position = Vector3.new(168.25759887695, 113.293800354, 91.533683776855)
MeshPart6.Color = Color3.new(0.972549, 0.972549, 0.972549)
MeshPart6.Size = Vector3.new(2.1650636196136, 0.5044721364975, 2.4995853900909)
MeshPart6.Anchored = true
MeshPart6.BrickColor = BrickColor.new("Institutional white")
MeshPart6.CanCollide = false
MeshPart6.Material = Enum.Material.Neon
MeshPart6.brickColor = BrickColor.new("Institutional white")
MeshPart7.Name = "Smash10"
MeshPart7.Parent = Folder0
MeshPart7.CFrame = CFrame.new(168.115692, 113.721008, 92.5011749, 1, 0, 0, 0, 1, 0, 0, 0, 1)
MeshPart7.Position = Vector3.new(168.11569213867, 113.72100830078, 92.501174926758)
MeshPart7.Color = Color3.new(0.972549, 0.972549, 0.972549)
MeshPart7.Size = Vector3.new(2.3776886463165, 0.50447225570679, 2.5000348091125)
MeshPart7.Anchored = true
MeshPart7.BrickColor = BrickColor.new("Institutional white")
MeshPart7.CanCollide = false
MeshPart7.Material = Enum.Material.Neon
MeshPart7.brickColor = BrickColor.new("Institutional white")
MeshPart8.Name = "IceCrystal"
MeshPart8.Parent = Folder0
MeshPart8.CFrame = CFrame.new(-162.928116, 115.678108, -48.5665741, 1, 0, 0, 0, 1, 0, 0, 0, 1)
MeshPart8.Position = Vector3.new(-162.92811584473, 115.67810821533, -48.56657409668)
MeshPart8.Color = Color3.new(0, 1, 1)
MeshPart8.Size = Vector3.new(2.5079998970032, 5.2529997825623, 3.5899999141693)
MeshPart8.Anchored = true
MeshPart8.BrickColor = BrickColor.new("Toothpaste")
MeshPart8.CanCollide = false
MeshPart8.Material = Enum.Material.Ice
MeshPart8.brickColor = BrickColor.new("Toothpaste")
MeshPart9.Name = "Crystal"
MeshPart9.Parent = Folder0
MeshPart9.CFrame = CFrame.new(-51.0063171, 116.464165, 24.7738743, 0, 1, 0, 0, 0, -1, -1, 0, 0)
MeshPart9.Orientation = Vector3.new(90, 90, 0)
MeshPart9.Position = Vector3.new(-51.006317138672, 116.46416473389, 24.773874282837)
MeshPart9.Rotation = Vector3.new(90, 0, -90)
MeshPart9.Color = Color3.new(0.972549, 0.972549, 0.972549)
MeshPart9.Size = Vector3.new(1.4142099618912, 1.4142099618912, 1.4142099618912)
MeshPart9.Anchored = true
MeshPart9.BrickColor = BrickColor.new("Institutional white")
MeshPart9.CanCollide = false
MeshPart9.Material = Enum.Material.Neon
MeshPart9.brickColor = BrickColor.new("Institutional white")
MeshPart10.Name = "Crown"
MeshPart10.Parent = Folder0
MeshPart10.CFrame = CFrame.new(165.539078, 113.2938, 89.1566544, 1, 0, 0, 0, 1, 0, 0, 0, 1)
MeshPart10.Position = Vector3.new(165.53907775879, 113.293800354, 89.15665435791)
MeshPart10.Color = Color3.new(0.972549, 0.972549, 0.972549)
MeshPart10.Size = Vector3.new(1.3364999294281, 2.3280100822449, 1.3498649597168)
MeshPart10.Anchored = true
MeshPart10.BrickColor = BrickColor.new("Institutional white")
MeshPart10.CanCollide = false
MeshPart10.Material = Enum.Material.Neon
MeshPart10.brickColor = BrickColor.new("Institutional white")
MeshPart11.Name = "Sawblade"
MeshPart11.Parent = Folder0
MeshPart11.CFrame = CFrame.new(-7.56640577, 19.7259312, -83.0128632, 1, 0, 0, 0, 1, 0, 0, 0, 1)
MeshPart11.Position = Vector3.new(-7.5664057731628, 19.725931167603, -83.01286315918)
MeshPart11.Color = Color3.new(1, 0, 0.317647)
MeshPart11.Size = Vector3.new(11.468522071838, 11.478637695313, 0.33516979217529)
MeshPart11.Anchored = true
MeshPart11.BrickColor = BrickColor.new("Really red")
MeshPart11.CanCollide = false
MeshPart11.Material = Enum.Material.Neon
MeshPart11.brickColor = BrickColor.new("Really red")
ParticleEmitter12.Name = "Mist"
ParticleEmitter12.Parent = mas
ParticleEmitter12.Speed = NumberRange.new(5, 12)
ParticleEmitter12.Color = ColorSequence.new(Color3.new(0.372549, 0, 0),Color3.new(0.372549, 0, 0))
ParticleEmitter12.Enabled = false
ParticleEmitter12.Texture = "rbxassetid://431361643"
ParticleEmitter12.Transparency = NumberSequence.new(0.89999997615814,1)
ParticleEmitter12.ZOffset = 2
ParticleEmitter12.Size = NumberSequence.new(0,3,3,3)
ParticleEmitter12.Drag = 6
ParticleEmitter12.Lifetime = NumberRange.new(2, 2)
ParticleEmitter12.Rate = 100
ParticleEmitter12.SpreadAngle = Vector2.new(360, 360)
ParticleEmitter12.VelocitySpread = 360
ParticleEmitter13.Name = "gibBlood"
ParticleEmitter13.Parent = mas
ParticleEmitter13.Speed = NumberRange.new(0, 0)
ParticleEmitter13.Color = ColorSequence.new(Color3.new(0.615686, 0, 0),Color3.new(0.615686, 0, 0))
ParticleEmitter13.Texture = "rbxassetid://4437071557"
ParticleEmitter13.Transparency = NumberSequence.new(0,1)
ParticleEmitter13.Size = NumberSequence.new(1,0)
ParticleEmitter13.EmissionDirection = Enum.NormalId.Bottom
ParticleEmitter13.Lifetime = NumberRange.new(0.5, 0.5)
ParticleEmitter13.Rate = 100
ParticleEmitter13.VelocityInheritance = 0.25
Model14.Name = "CrushedHead"
Model14.Parent = mas
Model14.PrimaryPart = Part23
UnionOperation15.Parent = Model14
UnionOperation15.CFrame = CFrame.new(-39.4868317, 5.62572479, -13.0110359, -1, 0, 0, 0, 1, 0, 0, 0, -1)
UnionOperation15.Orientation = Vector3.new(0, 180, 0)
UnionOperation15.Position = Vector3.new(-39.486831665039, 5.6257247924805, -13.011035919189)
UnionOperation15.Rotation = Vector3.new(-180, 0, -180)
UnionOperation15.Color = Color3.new(0.960784, 0.803922, 0.188235)
UnionOperation15.Size = Vector3.new(0.60869836807251, 0.57547563314438, 0.6060037612915)
UnionOperation15.Anchored = true
UnionOperation15.BrickColor = BrickColor.new("Bright yellow")
UnionOperation15.Locked = true
UnionOperation15.Material = Enum.Material.Metal
UnionOperation15.brickColor = BrickColor.new("Bright yellow")
UnionOperation15.UsePartColor = true
UnionOperation16.Parent = Model14
UnionOperation16.CFrame = CFrame.new(-38.8819427, 5.62572479, -13.0110359, -1, 0, 0, 0, 1, 0, 0, 0, -1)
UnionOperation16.Orientation = Vector3.new(0, 180, 0)
UnionOperation16.Position = Vector3.new(-38.881942749023, 5.6257247924805, -13.011035919189)
UnionOperation16.Rotation = Vector3.new(-180, 0, -180)
UnionOperation16.Color = Color3.new(0.960784, 0.803922, 0.188235)
UnionOperation16.Size = Vector3.new(0.60650587081909, 0.57547527551651, 0.60599994659424)
UnionOperation16.Anchored = true
UnionOperation16.BrickColor = BrickColor.new("Bright yellow")
UnionOperation16.Locked = true
UnionOperation16.Material = Enum.Material.Metal
UnionOperation16.brickColor = BrickColor.new("Bright yellow")
UnionOperation16.UsePartColor = true
UnionOperation17.Parent = Model14
UnionOperation17.CFrame = CFrame.new(-38.8822174, 6.20072079, -13.0110359, -1, 0, 0, 0, 1, 0, 0, 0, -1)
UnionOperation17.Orientation = Vector3.new(0, 180, 0)
UnionOperation17.Position = Vector3.new(-38.882217407227, 6.2007207870483, -13.011035919189)
UnionOperation17.Rotation = Vector3.new(-180, 0, -180)
UnionOperation17.Color = Color3.new(0.960784, 0.803922, 0.188235)
UnionOperation17.Size = Vector3.new(0.60706996917725, 0.57547545433044, 0.60599994659424)
UnionOperation17.Anchored = true
UnionOperation17.BrickColor = BrickColor.new("Bright yellow")
UnionOperation17.Locked = true
UnionOperation17.Material = Enum.Material.Metal
UnionOperation17.brickColor = BrickColor.new("Bright yellow")
UnionOperation17.UsePartColor = true
UnionOperation18.Parent = Model14
UnionOperation18.CFrame = CFrame.new(-39.4879303, 5.62572479, -12.4059477, 1, 0, 0, 0, 1, 0, 0, 0, 1)
UnionOperation18.Position = Vector3.new(-39.487930297852, 5.6257247924805, -12.405947685242)
UnionOperation18.Color = Color3.new(0.960784, 0.803922, 0.188235)
UnionOperation18.Size = Vector3.new(0.60650587081909, 0.57547527551651, 0.60599994659424)
UnionOperation18.Anchored = true
UnionOperation18.BrickColor = BrickColor.new("Bright yellow")
UnionOperation18.Locked = true
UnionOperation18.Material = Enum.Material.Metal
UnionOperation18.brickColor = BrickColor.new("Bright yellow")
UnionOperation18.UsePartColor = true
UnionOperation19.Parent = Model14
UnionOperation19.CFrame = CFrame.new(-39.4876404, 6.20072079, -12.4059477, 1, 0, 0, 0, 1, 0, 0, 0, 1)
UnionOperation19.Position = Vector3.new(-39.487640380859, 6.2007207870483, -12.405947685242)
UnionOperation19.Color = Color3.new(0.960784, 0.803922, 0.188235)
UnionOperation19.Size = Vector3.new(0.60706996917725, 0.57547545433044, 0.60599994659424)
UnionOperation19.Anchored = true
UnionOperation19.BrickColor = BrickColor.new("Bright yellow")
UnionOperation19.Locked = true
UnionOperation19.Material = Enum.Material.Metal
UnionOperation19.brickColor = BrickColor.new("Bright yellow")
UnionOperation19.UsePartColor = true
UnionOperation20.Parent = Model14
UnionOperation20.CFrame = CFrame.new(-38.8830261, 5.62572479, -12.4059401, 1, 0, 0, 0, 1, 0, 0, 0, 1)
UnionOperation20.Position = Vector3.new(-38.883026123047, 5.6257247924805, -12.405940055847)
UnionOperation20.Color = Color3.new(0.960784, 0.803922, 0.188235)
UnionOperation20.Size = Vector3.new(0.60869836807251, 0.57547563314438, 0.6060037612915)
UnionOperation20.Anchored = true
UnionOperation20.BrickColor = BrickColor.new("Bright yellow")
UnionOperation20.Locked = true
UnionOperation20.Material = Enum.Material.Metal
UnionOperation20.brickColor = BrickColor.new("Bright yellow")
UnionOperation20.UsePartColor = true
UnionOperation21.Parent = Model14
UnionOperation21.CFrame = CFrame.new(-38.8819427, 6.20072079, -12.4059858, 1, 0, 0, 0, 1, 0, 0, 0, 1)
UnionOperation21.Position = Vector3.new(-38.881942749023, 6.2007207870483, -12.405985832214)
UnionOperation21.Color = Color3.new(0.960784, 0.803922, 0.188235)
UnionOperation21.Size = Vector3.new(0.60650825500488, 0.57547563314438, 0.60608959197998)
UnionOperation21.Anchored = true
UnionOperation21.BrickColor = BrickColor.new("Bright yellow")
UnionOperation21.Locked = true
UnionOperation21.Material = Enum.Material.Metal
UnionOperation21.brickColor = BrickColor.new("Bright yellow")
UnionOperation21.UsePartColor = true
UnionOperation22.Parent = Model14
UnionOperation22.CFrame = CFrame.new(-39.4879303, 6.20072079, -13.0109816, -1, 0, 0, 0, 1, 0, 0, 0, -1)
UnionOperation22.Orientation = Vector3.new(0, 180, 0)
UnionOperation22.Position = Vector3.new(-39.487930297852, 6.2007207870483, -13.010981559753)
UnionOperation22.Rotation = Vector3.new(-180, 0, -180)
UnionOperation22.Color = Color3.new(0.960784, 0.803922, 0.188235)
UnionOperation22.Size = Vector3.new(0.60650825500488, 0.57547563314438, 0.60608959197998)
UnionOperation22.Anchored = true
UnionOperation22.BrickColor = BrickColor.new("Bright yellow")
UnionOperation22.Locked = true
UnionOperation22.Material = Enum.Material.Metal
UnionOperation22.brickColor = BrickColor.new("Bright yellow")
UnionOperation22.UsePartColor = true
Part23.Parent = Model14
Part23.CFrame = CFrame.new(-39.1871796, 5.92595291, -12.7115278, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part23.Position = Vector3.new(-39.18717956543, 5.925952911377, -12.711527824402)
Part23.Transparency = 1
Part23.Size = Vector3.new(0.10000000149012, 0.10000000149012, 0.10000000149012)
Part23.Anchored = true
Part23.BottomSurface = Enum.SurfaceType.Smooth
Part23.CanCollide = false
Part23.TopSurface = Enum.SurfaceType.Smooth
Model24.Name = "Morph"
Model24.Parent = mas
Model25.Name = "Head"
Model25.Parent = Model24
Model25.PrimaryPart = Part26
Part26.Name = "Head"
Part26.Parent = Model25
Part26.CFrame = CFrame.new(211.927994, 0.662, -90.1309967, -1, 0, 0, 0, 1, 0, 0, 0, -1)
Part26.Orientation = Vector3.new(0, 180, 0)
Part26.Position = Vector3.new(211.92799377441, 0.66200000047684, -90.130996704102)
Part26.Rotation = Vector3.new(-180, 0, -180)
Part26.Size = Vector3.new(2, 1, 1)
Part26.Anchored = true
Part26.BottomSurface = Enum.SurfaceType.Smooth
Part26.CanCollide = false
Part26.TopSurface = Enum.SurfaceType.Smooth
Decal27.Name = "Face"
Decal27.Parent = Part26
Decal27.Texture = "rbxasset://textures/face.png"
SpecialMesh28.Parent = Part26
SpecialMesh28.Scale = Vector3.new(1.25, 1.25, 1.25)
UnionOperation29.Name = "Mask"
UnionOperation29.Parent = Model25
UnionOperation29.CFrame = CFrame.new(211.927902, 0.66235292, -90.1313171, 1, 0, 0, 0, 1, 0, 0, 0, 1)
UnionOperation29.Position = Vector3.new(211.92790222168, 0.66235291957855, -90.131317138672)
UnionOperation29.Color = Color3.new(0.105882, 0.164706, 0.207843)
UnionOperation29.Size = Vector3.new(1.3041687011719, 1.2489281892776, 1.3026275634766)
UnionOperation29.Anchored = true
UnionOperation29.BrickColor = BrickColor.new("Black")
UnionOperation29.CanCollide = false
UnionOperation29.Material = Enum.Material.DiamondPlate
UnionOperation29.brickColor = BrickColor.new("Black")
UnionOperation29.UsePartColor = true
Model30.Name = "Right Arm"
Model30.Parent = Model24
Model30.PrimaryPart = Part31
Part31.Name = "WeldPart"
Part31.Parent = Model30
Part31.CFrame = CFrame.new(192.605743, 1.512977, -91.8248825, -1, 0, -8.74227766e-08, 0, 1, 0, 8.74227766e-08, 0, -1)
Part31.Orientation = Vector3.new(0, -180, 0)
Part31.Position = Vector3.new(192.6057434082, 1.5129770040512, -91.824882507324)
Part31.Rotation = Vector3.new(-180, 0, -180)
Part31.Size = Vector3.new(1, 2, 1)
Part31.Anchored = true
Part31.BottomSurface = Enum.SurfaceType.Smooth
Part31.CanCollide = false
Part31.TopSurface = Enum.SurfaceType.Smooth
UnionOperation32.Name = "Wire"
UnionOperation32.Parent = Model30
UnionOperation32.CFrame = CFrame.new(191.998657, 1.77530611, -91.8284225, 0.173649296, 8.88183028e-14, 0.984816015, 0.984804392, 2.84214214e-14, -0.17364724, -5.10445466e-14, 1.00000501, 3.78607363e-14)
UnionOperation32.Orientation = Vector3.new(10, 90, 90)
UnionOperation32.Position = Vector3.new(191.99865722656, 1.7753061056137, -91.828422546387)
UnionOperation32.Rotation = Vector3.new(90, 80, 0)
UnionOperation32.Color = Color3.new(0.458824, 0, 0)
UnionOperation32.Size = Vector3.new(1.4336805343628, 0.13597011566162, 0.56802368164063)
UnionOperation32.Anchored = true
UnionOperation32.BrickColor = BrickColor.new("Maroon")
UnionOperation32.CanCollide = false
UnionOperation32.Material = Enum.Material.SmoothPlastic
UnionOperation32.brickColor = BrickColor.new("Maroon")
UnionOperation33.Name = "Highlights"
UnionOperation33.Parent = Model30
UnionOperation33.CFrame = CFrame.new(192.516937, 1.88147449, -91.868782, -0.919813097, -0.392357051, 0, -0.392353088, 0.919803798, 0, 0, 0, -1)
UnionOperation33.Orientation = Vector3.new(0, 180, -23.10000038147)
UnionOperation33.Position = Vector3.new(192.51693725586, 1.8814744949341, -91.868782043457)
UnionOperation33.Rotation = Vector3.new(-180, 0, 156.89999389648)
UnionOperation33.Color = Color3.new(1, 0, 0)
UnionOperation33.Size = Vector3.new(1.9246520996094, 3.1341323852539, 1.4612035751343)
UnionOperation33.Anchored = true
UnionOperation33.BrickColor = BrickColor.new("Really red")
UnionOperation33.CanCollide = false
UnionOperation33.Material = Enum.Material.Neon
UnionOperation33.brickColor = BrickColor.new("Really red")
UnionOperation33.UsePartColor = true
UnionOperation34.Name = "Main"
UnionOperation34.Parent = Model30
UnionOperation34.CFrame = CFrame.new(192.446869, 1.99919796, -91.8693924, -1, 0, 0, 0, 1, 0, 0, 0, -1)
UnionOperation34.Orientation = Vector3.new(0, 180, 0)
UnionOperation34.Position = Vector3.new(192.44686889648, 1.9991979598999, -91.86939239502)
UnionOperation34.Rotation = Vector3.new(-180, 0, -180)
UnionOperation34.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
UnionOperation34.Size = Vector3.new(1.3851776123047, 3.0524876117706, 1.3839182853699)
UnionOperation34.Anchored = true
UnionOperation34.BrickColor = BrickColor.new("Really black")
UnionOperation34.CanCollide = false
UnionOperation34.Material = Enum.Material.Glass
UnionOperation34.brickColor = BrickColor.new("Really black")
UnionOperation34.UsePartColor = true
MeshPart35.Name = "Grenade"
MeshPart35.Parent = mas
MeshPart35.CFrame = CFrame.new(200.820786, 0.640009165, -91.5120392, 0, 0, -1, 0, 1, 0, 1, 0, 0)
MeshPart35.Orientation = Vector3.new(0, -90, 0)
MeshPart35.Position = Vector3.new(200.82078552246, 0.64000916481018, -91.51203918457)
MeshPart35.Rotation = Vector3.new(0, -90, 0)
MeshPart35.Size = Vector3.new(0.8415641784668, 1.1999999284744, 0.77592009305954)
MeshPart35.Anchored = true
MeshPart35.CanCollide = false
MeshPart35.TextureID = "rbxassetid://431532899"
Part36.Name = "ExplosionDebris"
Part36.Parent = mas
Part36.CFrame = CFrame.new(29.4349918, 5.65499973, -57.9250145, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part36.Position = Vector3.new(29.434991836548, 5.6549997329712, -57.92501449585)
Part36.Transparency = 1
Part36.Size = Vector3.new(0.050000000745058, 0.050000000745058, 0.050000000745058)
Part36.Anchored = true
Part36.BottomSurface = Enum.SurfaceType.Smooth
Part36.CanCollide = false
Part36.TopSurface = Enum.SurfaceType.Smooth
ParticleEmitter37.Parent = Part36
ParticleEmitter37.Speed = NumberRange.new(0, 0)
ParticleEmitter37.Color = ColorSequence.new(Color3.new(1, 0, 0),Color3.new(1, 1, 0))
ParticleEmitter37.LightEmission = 0.5
ParticleEmitter37.Texture = "rbxassetid://4437071557"
ParticleEmitter37.Transparency = NumberSequence.new(0,1)
ParticleEmitter37.Size = NumberSequence.new(2,0)
ParticleEmitter37.Lifetime = NumberRange.new(1, 1)
ParticleEmitter37.Rate = 300
for i,v in pairs(mas:GetChildren()) do
	v.Parent = script
	pcall(function() v:MakeJoints() end)
end
mas:Destroy()
for i,v in pairs(cors) do
	spawn(function()
		pcall(v)
	end)
end

if game:GetService("RunService"):IsClient() then error("Script must be server-side in order to work; use h/ and not hl/") end
local Player,game,owner = owner,game
local RealPlayer = Player
do
	print("FE Compatibility code by Mokiros")
	local rp = RealPlayer
	script.Parent = rp.Character

	--RemoteEvent for communicating
	local Event = Instance.new("RemoteEvent")
	Event.Name = "UserInput_Event"

	--Fake event to make stuff like Mouse.KeyDown work
	local function fakeEvent()
		local t = {_fakeEvent=true,Functions={},Connect=function(self,f)table.insert(self.Functions,f) end}
		t.connect = t.Connect
		return t
	end

	--Creating fake input objects with fake variables
	local m = {Target=nil,Hit=CFrame.new(),KeyUp=fakeEvent(),KeyDown=fakeEvent(),Button1Up=fakeEvent(),Button1Down=fakeEvent()}
	local UIS = {InputBegan=fakeEvent(),InputEnded=fakeEvent()}
	local CAS = {Actions={},BindAction=function(self,name,fun,touch,...)
		CAS.Actions[name] = fun and {Name=name,Function=fun,Keys={...}} or nil
	end}
	--Merged 2 functions into one by checking amount of arguments
	CAS.UnbindAction = CAS.BindAction

	--This function will trigger the events that have been :Connect()'ed
	local function te(self,ev,...)
		local t = m[ev]
		if t and t._fakeEvent then
			for _,f in pairs(t.Functions) do
				f(...)
			end
		end
	end
	m.TrigEvent = te
	UIS.TrigEvent = te

	Event.OnServerEvent:Connect(function(plr,io)
		if plr~=rp then return end
		m.Target = io.Target
		m.Hit = io.Hit
		if not io.isMouse then
			local b = io.UserInputState == Enum.UserInputState.Begin
			if io.UserInputType == Enum.UserInputType.MouseButton1 then
				return m:TrigEvent(b and "Button1Down" or "Button1Up")
			end
			for _,t in pairs(CAS.Actions) do
				for _,k in pairs(t.Keys) do
					if k==io.KeyCode then
						t.Function(t.Name,io.UserInputState,io)
					end
				end
			end
			m:TrigEvent(b and "KeyDown" or "KeyUp",io.KeyCode.Name:lower())
			UIS:TrigEvent(b and "InputBegan" or "InputEnded",io,false)
		end
	end)
	Event.Parent = NLS([==[
    local Player = game:GetService("Players").LocalPlayer
    local Event = script:WaitForChild("UserInput_Event")
 
    local Mouse = Player:GetMouse()
    local UIS = game:GetService("UserInputService")
    local input = function(io,a)
        if a then return end
        --Since InputObject is a client-side instance, we create and pass table instead
        Event:FireServer({KeyCode=io.KeyCode,UserInputType=io.UserInputType,UserInputState=io.UserInputState,Hit=Mouse.Hit,Target=Mouse.Target})
    end
    UIS.InputBegan:Connect(input)
    UIS.InputEnded:Connect(input)
 
    local h,t
    --Give the server mouse data 30 times every second, but only if the values changed
    --If player is not moving their mouse, client won't fire events
    while wait(1/30) do
        if h~=Mouse.Hit or t~=Mouse.Target then
            h,t=Mouse.Hit,Mouse.Target
            Event:FireServer({isMouse=true,Target=t,Hit=h})
        end
    end]==],Player.Character)

	----Sandboxed game object that allows the usage of client-side methods and services
	--Real game object
	local _rg = game

	--Metatable for fake service
	local fsmt = {
		__index = function(self,k)
			local s = rawget(self,"_RealService")
			if s then return s[k] end
		end,
		__newindex = function(self,k,v)
			local s = rawget(self,"_RealService")
			if s then s[k]=v end
		end,
		__call = function(self,...)
			local s = rawget(self,"_RealService")
			if s then return s(...) end
		end
	}
	local function FakeService(t,RealService)
		t._RealService = typeof(RealService)=="string" and _rg:GetService(RealService) or RealService
		return setmetatable(t,fsmt)
	end

	--Fake game object
	local g = {
		GetService = function(self,s)
			return self[s]
		end,
		Players = FakeService({
			LocalPlayer = FakeService({GetMouse=function(self)return m end},Player)
		},"Players"),
		UserInputService = FakeService(UIS,"UserInputService"),
		ContextActionService = FakeService(CAS,"ContextActionService"),
	}
	rawset(g.Players,"localPlayer",g.Players.LocalPlayer)
	g.service = g.GetService

	g.RunService = FakeService({
		RenderStepped = _rg:GetService("RunService").Heartbeat,
		BindToRenderStep = function(self,name,_,fun)
			self._btrs[name] = self.Heartbeat:Connect(fun)
		end,
		UnbindFromRenderStep = function(self,name)
			self._btrs[name]:Disconnect()
		end,
	},"RunService")

	setmetatable(g,{
		__index=function(self,s)
			return _rg:GetService(s) or typeof(_rg[s])=="function"
				and function(_,...)return _rg[s](_rg,...)end or _rg[s]
		end,
		__newindex = fsmt.__newindex,
		__call = fsmt.__call
	})
	--Changing owner to fake player object to support owner:GetMouse()
	game,owner = g,g.Players.LocalPlayer
end

local LOCALSCRIPTGAME = game

--// SHORTCUTS \\--
local RNG = (function()
	local RNG = Random.new();
	return function(min,max,int)
		return int and RNG:NextInteger(min,max) or RNG:NextNumber(min,max)
	end;
end)();
local CF = {
	N=CFrame.new;
	A=CFrame.Angles;
	fEA=CFrame.fromEulerAnglesXYZ;
}
local C3 = {
	N=Color3.new;
	RGB=Color3.fromRGB;
	HSV=function(...)local data={...}if(typeof(data)=='Color3')then return Color3.toHSV(...)else return Color3.fromHSV(...)end;end;
}
local V3 = {
	N=Vector3.new;
	FNI=Vector3.FromNormalId;
	A=Vector3.FromAxis;
}
local M = {
	C=math.cos;
	R=math.rad;
	S=math.sin;
	T=math.tan;
	AT=math.atan;
	AT2=math.atan2;
	AS=math.asin;
	AC=math.acos;
	A=math.abs;
	F=math.floor;
	CE=math.ceil;
	P=math.pi;
	RNG=RNG;
	H=math.huge;
	RRNG=function(...) return math.rad(RNG(...)) end
}
local R3 = Region3.new
local De = REALGAME.Debris
local WS = workspace
local Lght = game.Lighting
local RepS = game.ReplicatedStorage
local IN = Instance.new
local Plrs = game.Players

--// INITIALIZATION \\--
local Plr = Plrs.LocalPlayer
local Char = Plr.Character
local Hum = Char:FindFirstChildOfClass'Humanoid'
assert(Hum and Hum.RigType==Enum.HumanoidRigType.R6,"You need to have a valid Humanoid instance! (Exising and R6)")
local Head = Char.Head
local RArm = Char["Right Arm"]
local LArm = Char["Left Arm"]
local RLeg = Char["Right Leg"]
local LLeg = Char["Left Leg"]	
local Torso= Char.Torso
local Root = Char.HumanoidRootPart
local NeutralAnims = true
local Attack = false
local legAnims = true
local Mouse = Plr:GetMouse()
local EffectFolder=Instance.new("Folder")
EffectFolder.Name='Effects'
EffectFolder.Parent=Char
local FXFolder = script:WaitForChild'Effects'
FXFolder.Parent=nil
Vector3Sequence={}
Vector3SequenceKeypoint={}

Vector3SequenceKeypoint.new = function(time,value,envelope)
	--bad argument #2 to 'new' (number expected, got Vector3)
	assert(typeof(time)=='number',"bad argument #1 to 'new' (number expected, got "..typeof(time))
	assert(typeof(value)=='Vector3',"bad argument #2 to 'new' (Vector3 expected, got "..typeof(value))
	return {Time=time,Value=value,Envelope=envelope}
end

Vector3Sequence.new = function(...)
	local tuple={...}
	if(#tuple==2)then
		return Vector3Sequence.new{Vector3SequenceKeypoint.new(0,tuple[1]),Vector3SequenceKeypoint.new(1,tuple[2])}
	else
		local thing = tuple[1]
		if(typeof(thing)=='Vector3')then
			return Vector3Sequence.new(thing,thing)
		elseif(typeof(thing)=='table')then
			assert(#thing>=2,"Vector3Sequence: requires at least 2 keypoints")
			local last;
			for i,v in next, thing do
				assert(v.Value and v.Time and typeof(v.Value)=='Vector3',"expected 'Vector3SequenceKeypoint' at index "..i)
				if(not last or v.Time>last)then
					last=v.Time
				else
					error("Vector3Sequence: all keypoints must be ordered by time")
				end
			end
			return setmetatable({
				Keypoints=thing;
			},{__index=Vector3Sequence})
		else
			return error("table of Vector3SequenceKeypoints expected.")
		end
	end
end

CFrameSequence={}
CFrameSequenceKeypoint={}

CFrameSequenceKeypoint.new = function(time,value,envelope)
	--bad argument #2 to 'new' (number expected, got CFrame)
	assert(typeof(time)=='number',"bad argument #1 to 'new' (number expected, got "..typeof(time))
	assert(typeof(value)=='CFrame',"bad argument #2 to 'new' (CFrame expected, got "..typeof(value))
	return {Time=time,Value=value,Envelope=envelope}
end

CFrameSequence.new = function(...)
	local tuple={...}
	if(#tuple==2)then
		return CFrameSequence.new{CFrameSequenceKeypoint.new(0,tuple[1]),CFrameSequenceKeypoint.new(1,tuple[2])}
	else
		local thing = tuple[1]
		if(typeof(thing)=='CFrame')then
			return CFrameSequence.new(thing,thing)
		elseif(typeof(thing)=='table')then
			assert(#thing>=2,"CFrameSequence: requires at least 2 keypoints")
			local last;
			for i,v in next, thing do
				assert(v.Value and v.Time and typeof(v.Value)=='CFrame',"expected 'CFrameSequenceKeypoint' at index "..i)
				if(not last or v.Time>last)then
					last=v.Time
				else
					error("CFrameSequence: all keypoints must be ordered by time")
				end
			end
			return setmetatable({
				Keypoints=thing;
			},{__index=CFrameSequence})
		else
			return error("table of CFrameSequenceKeypoints expected.")
		end
	end
end

local ExplosionDeb = script:WaitForChild'ExplosionDebris'
ExplosionDeb.Parent=nil
local GibParticles = script:WaitForChild'gibBlood'
GibParticles.Parent=nil
local Movement = 8
local Sine = 0;
local Change = 1;
local wsVal = 8
local crushedHead = script:WaitForChild'CrushedHead'
crushedHead.Parent=nil
local BloodParticles = IN("Attachment")
script:WaitForChild'Mist'.Parent=BloodParticles

--// INSTANCE CREATORS \\--
local baseSound = IN("Sound")
function Sound(parent,id,pitch,volume,looped,effect,autoPlay)
	local Sound = baseSound:Clone()
	Sound.SoundId = "rbxassetid://".. tostring(id or 0)
	Sound.Pitch = pitch or 1
	Sound.Volume = volume or 1
	Sound.Looped = looped or false
	if(autoPlay)then
		coroutine.wrap(function()
			repeat wait() until Sound.IsLoaded
			Sound.Playing = autoPlay or false
		end)()
	end
	if(not looped and effect)then
		Sound.Stopped:connect(function()
			Sound.Volume = 0
			Sound:destroy()
		end)
	elseif(effect)then
		warn("Sound can't be looped and a sound effect!")
	end
	Sound.Parent =parent or workspace
	return Sound
end
function Part(parent,color,material,size,cframe,anchored,cancollide)
	local part = IN("Part")
	part[typeof(color) == 'BrickColor' and 'BrickColor' or 'Color'] = color or C3.N(0,0,0)
	part.Material = material or Enum.Material.SmoothPlastic
	part.TopSurface,part.BottomSurface=10,10
	part.Size = size or V3.N(1,1,1)
	part.CFrame = cframe or CF.N(0,0,0)
	part.CanCollide = cancollide or false
	part.Anchored = anchored or false
	part.Parent = parent
	return part
end

function Weld(part0,part1,c0,c1)
	local weld = IN("Weld")
	weld.Part0 = part0
	weld.Part1 = part1
	weld.C0 = c0 or CF.N()
	weld.C1 = c1 or CF.N()
	weld.Parent = part0
	return weld
end

function Mesh(parent,meshtype,meshid,textid,scale,offset)
	local part = IN("SpecialMesh")
	part.MeshId = meshid or ""
	part.TextureId = textid or ""
	part.Scale = scale or V3.N(1,1,1)
	part.Offset = offset or V3.N(0,0,0)
	part.MeshType = meshtype or Enum.MeshType.Sphere
	part.Parent = parent
	return part
end

function SoundPart(id,pitch,volume,looped,effect,autoPlay,cf)
	local soundPart = Part(EffectFolder,C3.N(1,1,1),Enum.Material.SmoothPlastic,V3.N(.05,.05,.05),cf,true,false)
	soundPart.Transparency=1
	local Sound = IN("Sound")
	Sound.SoundId = "rbxassetid://".. tostring(id or 0)
	Sound.Pitch = pitch or 1
	Sound.Volume = volume or 1
	Sound.Looped = looped or false
	if(autoPlay)then
		coroutine.wrap(function()
			repeat wait() until Sound.IsLoaded
			Sound.Playing = autoPlay or false
		end)()
	end
	if(not looped and effect)then
		Sound.Stopped:connect(function()
			Sound.Volume = 0
			soundPart:destroy()
		end)
	elseif(effect)then
		warn("Sound can't be looped and a sound effect!")
	end
	Sound.Parent = soundPart
	return Sound
end

function Joint(name,part0,part1,c0,c1,type)
	local joint = IN(type or "Motor6D")
	joint.Part0 = part0
	joint.Part1 = part1
	joint.C0 = c0 or CF.N()
	joint.C1 = c1 or CF.N()
	joint.Parent=part0
	joint.Name=name or part0.." to "..part1.." "..joint.ClassName
	return joint
end

function Animate(joint,c0,alpha,style,dir)
	if(style=='Lerp')then
		joint.C0 = joint.C0:lerp(c0,alpha)
	else
		local info = TweenInfo.new(alpha or 1,style or Enum.EasingStyle.Linear,dir or Enum.EasingDirection.Out,0,false,0)
		local tween = REALGAME:GetService("TweenService"):Create(joint,info,{C0=c0})
		tween:Play();
		return tween;
	end
end

function NewInstance(instance,parent,properties)if(properties.Parent)then properties.Parent=parent end;local new = IN(instance)if(properties)then for prop,val in next, properties do pcall(function() new[prop]=val end)end;end;new.Parent=parent;return new;end

function GetAdjacentParts(part)
	local function createLargerHitbox(part)
		local n = 0.2
		local clone = part:Clone()

		clone.Transparency = .8
		clone.BrickColor = BrickColor.Red()
		clone.Size = clone.Size + Vector3.new(n, n, n)
		clone.Name = "hitbox"
		clone.CFrame = part.CFrame
		clone.Anchored=true
		clone.CanCollide=true

		if (clone:IsA("WedgePart")) then
			clone.Size = clone.Size + Vector3.new(0, n, n)
			clone.CFrame = part.CFrame * CFrame.new(0, n / 2, -n /2)
		end

		if (clone:IsA("CornerWedgePart")) then
			clone.Size = clone.Size + Vector3.new(n, n, n)
			clone.CFrame = part.CFrame * CFrame.new(-n / 2, n / 2, n / 2)
		end
		clone.Parent = part

		return clone
	end

	local hitbox = createLargerHitbox(part)
	local touchingParts = hitbox:getTouchingParts()
	hitbox:Destroy()

	return (function()
		local adjacent={}
		for _,v in next, touchingParts do if(v~=part)then table.insert(adjacent,v)end;end
		return adjacent;
	end)()
end
--// CUSTOMIZABLE VARIABLES \\--
local Gren = script:WaitForChild'Grenade'
local ShakeFactor = 2
local DamageColor = BrickColor.new'Really red';
local MusicData = {Parent=Torso,ID=614032233;Pitch=1;Volume=2;}
local God = true
local WalkSpeed = 16

local Music = Instance.new("Sound", owner.Character.Torso)
Music.SoundId = "rbxassetid://4466439348"
Music.Volume = 1
Music.Name = 'Music'
Music:Play()

local Morph = script:WaitForChild'Morph'
local Highlights=Morph:WaitForChild'Right Arm':WaitForChild'Highlights'
for _,v in next, Char:children() do
	if(Morph:FindFirstChild(v.Name))then
		local part = Morph[v.Name]
		part.Parent=Char
		part:SetPrimaryPartCFrame(v.CFrame)
		for _,c in next, part:GetDescendants() do
			if(c:IsA'BasePart' and c~=part.PrimaryPart)then
				c.Massless=true
				c.Anchored=false
				local j = Weld(v,c,CFrame.new(),c.CFrame:inverse()*v.CFrame)
				c.CanCollide=false
			end
		end
		part.PrimaryPart:destroy()
	end
end

--// JOINTS \\--

local RJ = Joint("RootJoint",Root,Torso,CF.N(),CF.N())
local NK = Joint("Neck",Torso,Head,CF.N(0,1.5,0),CF.N())
local LS = Joint("Left Shoulder",Torso,LArm,CF.N(-1.5,.5,0),CF.N(0,.5,0))
local RS = Joint("Right Shoulder",Torso,RArm,CF.N(1.5,.5,0),CF.N(0,.5,0))
local LH = Joint("Left Hip",Torso,LLeg,CF.N(-.5,-2,0),CF.N(0,0,0))
local RH = Joint("Right Hip",Torso,RLeg,CF.N(.5,-2,0),CF.N(0,0,0))

local LSC0 = LS.C0
local RSC0 = RS.C0
local NKC0 = NK.C0
local LHC0 = LH.C0
local RHC0 = RH.C0
local RJC0 = RJ.C0

--// Artificial HB \\--

local ArtificialHB = IN("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"

script:WaitForChild("Heartbeat")

local tf = 0
local allowframeloss = false
local tossremainder = false
local lastframe = tick()
local frame = 1/60
ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function swait(num)
	if num == 0 or num == nil then
		ArtificialHB.Event:wait()
	else
		for i = 0, num do
			ArtificialHB.Event:wait()
		end
	end
end

--// STOP ANIMATIONS \\--
for _,v in next, Hum:GetPlayingAnimationTracks() do
	v:Stop();
end
pcall(function()
	Char:FindFirstChild'Animate':Destroy()
end)
pcall(function()
	Hum:FindFirstChild'Animator':Destroy()
end)

--// EFFECT FUNCTIONS \\--
--
-- Adapted from
-- Tweener's easing functions (Penner's Easing Equations)
-- and http://code.google.com/p/tweener/ (jstweener javascript version)
--

--[[
Disclaimer for Robert Penner's Easing Equations license:

TERMS OF USE - EASING EQUATIONS

Open source under the BSD License.

Copyright © 2001 Robert Penner
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
    * Neither the name of the author nor the names of contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
]]

-- For all easing functions:
-- t = elapsed time
-- b = begin
-- c = change == ending - beginning
-- d = duration (total time)

local pow = math.pow
local sin = math.sin
local cos = math.cos
local pi = math.pi
local sqrt = math.sqrt
local abs = math.abs
local asin  = math.asin

local function linear(t, b, c, d)
	return c * t / d + b
end

local function inQuad(t, b, c, d)
	t = t / d
	return c * pow(t, 2) + b
end

local function outQuad(t, b, c, d)
	t = t / d
	return -c * t * (t - 2) + b
end

local function inOutQuad(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return c / 2 * pow(t, 2) + b
	else
		return -c / 2 * ((t - 1) * (t - 3) - 1) + b
	end
end

local function outInQuad(t, b, c, d)
	if t < d / 2 then
		return outQuad (t * 2, b, c / 2, d)
	else
		return inQuad((t * 2) - d, b + c / 2, c / 2, d)
	end
end

local function inCubic (t, b, c, d)
	t = t / d
	return c * pow(t, 3) + b
end

local function outCubic(t, b, c, d)
	t = t / d - 1
	return c * (pow(t, 3) + 1) + b
end

local function inOutCubic(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return c / 2 * t * t * t + b
	else
		t = t - 2
		return c / 2 * (t * t * t + 2) + b
	end
end

local function outInCubic(t, b, c, d)
	if t < d / 2 then
		return outCubic(t * 2, b, c / 2, d)
	else
		return inCubic((t * 2) - d, b + c / 2, c / 2, d)
	end
end

local function inQuart(t, b, c, d)
	t = t / d
	return c * pow(t, 4) + b
end

local function outQuart(t, b, c, d)
	t = t / d - 1
	return -c * (pow(t, 4) - 1) + b
end

local function inOutQuart(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return c / 2 * pow(t, 4) + b
	else
		t = t - 2
		return -c / 2 * (pow(t, 4) - 2) + b
	end
end

local function outInQuart(t, b, c, d)
	if t < d / 2 then
		return outQuart(t * 2, b, c / 2, d)
	else
		return inQuart((t * 2) - d, b + c / 2, c / 2, d)
	end
end

local function inQuint(t, b, c, d)
	t = t / d
	return c * pow(t, 5) + b
end

local function outQuint(t, b, c, d)
	t = t / d - 1
	return c * (pow(t, 5) + 1) + b
end

local function inOutQuint(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return c / 2 * pow(t, 5) + b
	else
		t = t - 2
		return c / 2 * (pow(t, 5) + 2) + b
	end
end

local function outInQuint(t, b, c, d)
	if t < d / 2 then
		return outQuint(t * 2, b, c / 2, d)
	else
		return inQuint((t * 2) - d, b + c / 2, c / 2, d)
	end
end

local function inSine(t, b, c, d)
	return -c * cos(t / d * (pi / 2)) + c + b
end

local function outSine(t, b, c, d)
	return c * sin(t / d * (pi / 2)) + b
end

local function inOutSine(t, b, c, d)
	return -c / 2 * (cos(pi * t / d) - 1) + b
end

local function outInSine(t, b, c, d)
	if t < d / 2 then
		return outSine(t * 2, b, c / 2, d)
	else
		return inSine((t * 2) -d, b + c / 2, c / 2, d)
	end
end

local function inExpo(t, b, c, d)
	if t == 0 then
		return b
	else
		return c * pow(2, 10 * (t / d - 1)) + b - c * 0.001
	end
end

local function outExpo(t, b, c, d)
	if t == d then
		return b + c
	else
		return c * 1.001 * (-pow(2, -10 * t / d) + 1) + b
	end
end

local function inOutExpo(t, b, c, d)
	if t == 0 then return b end
	if t == d then return b + c end
	t = t / d * 2
	if t < 1 then
		return c / 2 * pow(2, 10 * (t - 1)) + b - c * 0.0005
	else
		t = t - 1
		return c / 2 * 1.0005 * (-pow(2, -10 * t) + 2) + b
	end
end

local function outInExpo(t, b, c, d)
	if t < d / 2 then
		return outExpo(t * 2, b, c / 2, d)
	else
		return inExpo((t * 2) - d, b + c / 2, c / 2, d)
	end
end

local function inCirc(t, b, c, d)
	t = t / d
	return(-c * (sqrt(1 - pow(t, 2)) - 1) + b)
end

local function outCirc(t, b, c, d)
	t = t / d - 1
	return(c * sqrt(1 - pow(t, 2)) + b)
end

local function inOutCirc(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return -c / 2 * (sqrt(1 - t * t) - 1) + b
	else
		t = t - 2
		return c / 2 * (sqrt(1 - t * t) + 1) + b
	end
end

local function outInCirc(t, b, c, d)
	if t < d / 2 then
		return outCirc(t * 2, b, c / 2, d)
	else
		return inCirc((t * 2) - d, b + c / 2, c / 2, d)
	end
end

local function inElastic(t, b, c, d, a, p)
	if t == 0 then return b end

	t = t / d

	if t == 1  then return b + c end

	if not p then p = d * 0.3 end

	local s

	if not a or a < abs(c) then
		a = c
		s = p / 4
	else
		s = p / (2 * pi) * asin(c/a)
	end

	t = t - 1

	return -(a * pow(2, 10 * t) * sin((t * d - s) * (2 * pi) / p)) + b
end

-- a: amplitud
-- p: period
local function outElastic(t, b, c, d, a, p)
	if t == 0 then return b end

	t = t / d

	if t == 1 then return b + c end

	if not p then p = d * 0.3 end

	local s

	if not a or a < abs(c) then
		a = c
		s = p / 4
	else
		s = p / (2 * pi) * asin(c/a)
	end

	return a * pow(2, -10 * t) * sin((t * d - s) * (2 * pi) / p) + c + b
end

-- p = period
-- a = amplitud
local function inOutElastic(t, b, c, d, a, p)
	if t == 0 then return b end

	t = t / d * 2

	if t == 2 then return b + c end

	if not p then p = d * (0.3 * 1.5) end
	if not a then a = 0 end

	local s

	if not a or a < abs(c) then
		a = c
		s = p / 4
	else
		s = p / (2 * pi) * asin(c / a)
	end

	if t < 1 then
		t = t - 1
		return -0.5 * (a * pow(2, 10 * t) * sin((t * d - s) * (2 * pi) / p)) + b
	else
		t = t - 1
		return a * pow(2, -10 * t) * sin((t * d - s) * (2 * pi) / p ) * 0.5 + c + b
	end
end

-- a: amplitud
-- p: period
local function outInElastic(t, b, c, d, a, p)
	if t < d / 2 then
		return outElastic(t * 2, b, c / 2, d, a, p)
	else
		return inElastic((t * 2) - d, b + c / 2, c / 2, d, a, p)
	end
end

local function inBack(t, b, c, d, s)
	if not s then s = 1.70158 end
	t = t / d
	return c * t * t * ((s + 1) * t - s) + b
end

local function outBack(t, b, c, d, s)
	if not s then s = 1.70158 end
	t = t / d - 1
	return c * (t * t * ((s + 1) * t + s) + 1) + b
end

local function inOutBack(t, b, c, d, s)
	if not s then s = 1.70158 end
	s = s * 1.525
	t = t / d * 2
	if t < 1 then
		return c / 2 * (t * t * ((s + 1) * t - s)) + b
	else
		t = t - 2
		return c / 2 * (t * t * ((s + 1) * t + s) + 2) + b
	end
end

local function outInBack(t, b, c, d, s)
	if t < d / 2 then
		return outBack(t * 2, b, c / 2, d, s)
	else
		return inBack((t * 2) - d, b + c / 2, c / 2, d, s)
	end
end

local function outBounce(t, b, c, d)
	t = t / d
	if t < 1 / 2.75 then
		return c * (7.5625 * t * t) + b
	elseif t < 2 / 2.75 then
		t = t - (1.5 / 2.75)
		return c * (7.5625 * t * t + 0.75) + b
	elseif t < 2.5 / 2.75 then
		t = t - (2.25 / 2.75)
		return c * (7.5625 * t * t + 0.9375) + b
	else
		t = t - (2.625 / 2.75)
		return c * (7.5625 * t * t + 0.984375) + b
	end
end

local function inBounce(t, b, c, d)
	return c - outBounce(d - t, 0, c, d) + b
end

local function inOutBounce(t, b, c, d)
	if t < d / 2 then
		return inBounce(t * 2, 0, c, d) * 0.5 + b
	else
		return outBounce(t * 2 - d, 0, c, d) * 0.5 + c * .5 + b
	end
end

local function outInBounce(t, b, c, d)
	if t < d / 2 then
		return outBounce(t * 2, b, c / 2, d)
	else
		return inBounce((t * 2) - d, b + c / 2, c / 2, d)
	end
end

local EasingFunctions = {
	linear = linear,
	inQuad = inQuad,
	outQuad = outQuad,
	inOutQuad = inOutQuad,
	outInQuad = outInQuad,
	inCubic  = inCubic ,
	outCubic = outCubic,
	inOutCubic = inOutCubic,
	outInCubic = outInCubic,
	inQuart = inQuart,
	outQuart = outQuart,
	inOutQuart = inOutQuart,
	outInQuart = outInQuart,
	inQuint = inQuint,
	outQuint = outQuint,
	inOutQuint = inOutQuint,
	outInQuint = outInQuint,
	inSine = inSine,
	outSine = outSine,
	inOutSine = inOutSine,
	outInSine = outInSine,
	inExpo = inExpo,
	outExpo = outExpo,
	inOutExpo = inOutExpo,
	outInExpo = outInExpo,
	inCirc = inCirc,
	outCirc = outCirc,
	inOutCirc = inOutCirc,
	outInCirc = outInCirc,
	inElastic = inElastic,
	outElastic = outElastic,
	inOutElastic = inOutElastic,
	outInElastic = outInElastic,
	inBack = inBack,
	outBack = outBack,
	inOutBack = inOutBack,
	outInBack = outInBack,
	inBounce = inBounce,
	outBounce = outBounce,
	inOutBounce = inOutBounce,
	outInBounce = outInBounce,
}


local fromaxisangle = function(x, y, z) -- credit to phantom forces devs
	if not y then
		x, y, z = x.x, x.y, x.z
	end
	local m = (x * x + y * y + z * z) ^ 0.5
	if m > 1.0E-5 then
		local si = math.sin(m / 2) / m
		return CFrame.new(0, 0, 0, si * x, si * y, si * z, math.cos(m / 2))
	else
		return CFrame.new()
	end
end

function fakePhysics(elapsed,cframe,velocity,rotation,acceleration)
	local pos = cframe.p
	local matrix = cframe-pos
	return fromaxisangle(elapsed*rotation)*matrix+pos+elapsed*velocity+elapsed*elapsed*acceleration
end

function CastRay(startPos,endPos,range,ignoreList)
	local ray = Ray.new(startPos,(endPos-startPos).unit*range)
	local part,pos,norm = workspace:FindPartOnRayWithIgnoreList(ray,ignoreList or {Char},false,true)
	return part,pos,norm,(pos and (startPos-pos).magnitude)
end

function GetTorso(char)
	return char:FindFirstChild'Torso' or char:FindFirstChild'UpperTorso' or char:FindFirstChild'LowerTorso' or char:FindFirstChild'HumanoidRootPart'
end

function Projectile(data)
	local Size = data.Size or 1;
	local Origin = data.Origin or CFrame.new();
	local Velocity = data.Velocity or Vector3.new(0,100,0);
	local Gravity = data.Gravity or workspace.Gravity;
	local Color = data.Color or Color3.new(.7,0,0);
	local Lifetime = data.Lifetime or 1;
	local Material = data.Material or Enum.Material.Glass;
	local ignore = data.Ignorelist or {Char};
	local Init = data.Init;
	local Update = data.Update;
	local HitFunc = data.Hit;
	local ShouldCollide = data.BeforeCollision;
	local DeleteOnHit = not not data.DeleteOnHit;
	local ProjectilePart = data.Projectile or nil;
	local Look = data.AimAtPos or false;
	local drop = ProjectilePart or Part(nil,Color,Material,Vector3.new(Size,Size,Size),Origin,true,false)
	local StartTravel = tick()
	local currCF = data.Origin
	if(not ProjectilePart)then
		Mesh(drop,Enum.MeshType.Sphere)
		drop.Parent=EffectFolder
	end
	drop.Material = Material
	drop.Color = Color
	drop.CFrame=Origin
	local object=setmetatable({Part=drop},{
		__newindex=function(s,i,v)
			if(i=='Gravity')then StartTravel = tick() data.Origin = currCF Origin=currCF data.Gravity = v Gravity=v
			elseif(i=='Velocity')then StartTravel = tick() data.Origin = currCF Origin=currCF data.Velocity = v Velocity=v
			elseif(i=='Lifetime')then data.Lifetime = v Lifetime=v 
			elseif(i=='Ignorelist')then data.Ignorelist = v ignore=v
			elseif(i=='DeleteOnHit')then data.DeleteOnHit = v DeleteOnHit=v 
			else
				pcall(function()
					drop[i]=v
				end)
			end
		end;
		__index=data;
	})


	if(Init)then
		Init(drop)
	end
	local startTick = tick();
	coroutine.wrap(function()
		while true do
			local elapsed = tick()-startTick
			local trElapsed = tick()-StartTravel
			if(elapsed>Lifetime)then
				drop:destroy();
				break
			end
			local newCF = fakePhysics(trElapsed,Origin,Velocity,Vector3.new(),Vector3.new(0,-Gravity,0))
			local nextCF = fakePhysics(trElapsed+.05,Origin,Velocity,Vector3.new(),Vector3.new(0,-Gravity,0))
			local dist = (drop.Position-newCF.p).magnitude
			local hit,pos,norm = CastRay(drop.Position,newCF.p,dist,ignore)
			currCF=newCF
			local doCollide = hit and (GetTorso(hit.Parent) or hit.CanCollide) and (not ShouldCollide or ShouldCollide(hit))
			if(hit and not doCollide)then table.insert(ignore,hit) end
			if(Look)then
				drop.CFrame = CFrame.new(newCF.p,nextCF.p)
			else
				drop.CFrame = CFrame.new(newCF.p)
			end
			if(Update)then Update(drop,object,elapsed) end
			if(doCollide)then
				if(DeleteOnHit or not HitFunc)then drop:destroy() end
				if(HitFunc)then if(HitFunc(hit,pos,norm,object,drop))then break end end
			end
			if(not drop.Parent)then
				break
			end
			swait()
		end
	end)()
	return object
end

function Chat(txt,Timer,Alpha,clr)
	if(Head:FindFirstChild'Chattie' and Head.Chattie:FindFirstChild'Killchat')then
		Head.Chattie.Killchat.Value=true
	elseif(Head:FindFirstChild'Chattie')then
		Head.Chattie:destroy()
	end
	local nig = V3.N(0,0,0)
	local clr = (typeof(clr)=='BrickColor' and clr.Color or typeof(clr)=='Color3' and clr or C3.N(1,1,1))
	local bg = NewInstance("BillboardGui",Head,{
		Name='Chattie';
		Adornee=Head;
		LightInfluence=0;
		Size=UDim2.new(4,0,2,0);
	})
	local dismiss = NewInstance("BoolValue",bg,{
		Name='Killchat';
	})

	local text = NewInstance("TextLabel",bg,{
		BackgroundTransparency=1;
		Size=UDim2.new(1,0,1,0);
		Font=Enum.Font.Fantasy;
		Text=txt;
		TextColor3=clr;
		TextStrokeColor3=C3.N(0,0,0);
		TextScaled=true;
		TextTransparency=0;
		TextStrokeTransparency=.5;
	})
	coroutine.wrap(function()
		for i = 1, 0, -.02 do
			bg.StudsOffsetWorldSpace=nig:lerp(nig+V3.N(0,3,0),EasingFunctions.outBack(1-i,0,1,1,6))
			if(dismiss.Value)then break end
			swait()
		end
		local start = tick()
		nig=bg.StudsOffsetWorldSpace
		repeat swait() until dismiss.Value or tick()-start>=timer
		bg.Name='DismissingChat'
		for i = 0, 1, .05 do
			bg.StudsOffsetWorldSpace=nig:lerp(nig+V3.N(0,2,0),EasingFunctions.linear(i,0,1,1))
			text.TextTransparency=i;
			text.TextStrokeTransparency=.5+i/2;
			swait()
		end
		bg:destroy()
	end)()
end

function ShowDamage(pos,txt,timer,clr)
	local nig = typeof(pos)=='Vector3' and CF.N(pos) or pos
	local part = Part(EffectFolder,clr,Enum.Material.SmoothPlastic,V3.N(.05,.05,.05),nig,true,false)
	part.Transparency=1
	local bg = NewInstance("BillboardGui",part,{
		Adornee=part;
		LightInfluence=0;
		Size=UDim2.new(2,0,1,0);
	})
	local text = NewInstance("TextLabel",bg,{
		BackgroundTransparency=1;
		Size=UDim2.new(1,0,1,0);
		Font=Enum.Font.Fantasy;
		Text=txt;
		TextColor3=part.Color;
		TextStrokeColor3=C3.N(0,0,0);
		TextScaled=true;
		TextTransparency=1;
		TextStrokeTransparency=1;
	})
	coroutine.wrap(function()
		for i = 1, 0, -.02 do
			part.CFrame=nig:lerp(nig+V3.N(0,3,0),EasingFunctions.outBack(1-i,0,1,1,6))
			text.TextTransparency=i;
			text.TextTransparency=text.TextTransparency-.02;
			text.TextStrokeTransparency=text.TextStrokeTransparency-.01;
			swait()
		end
		local start = tick()
		repeat swait() until tick()-start>=timer
		local endRot=M.RNG(-25,25)
		for i = 0, 1, .02 do
			part.CFrame=(nig+V3.N(0,3,0)):lerp(nig+V3.N(0,-10,0),EasingFunctions.inBack(i,0,1,1,6))
			text.TextTransparency=i;
			text.TextTransparency=text.TextTransparency+.02;
			text.TextStrokeTransparency=text.TextStrokeTransparency+.01;
			swait()
		end
		part:destroy()
	end)()
end

function CamshakePlayer(p,settings)

end

function Camshake(settings)

end
function Tween(object,properties,time,style,dir,repeats,reverse,delay)
	local info = TweenInfo.new(time or 1,style or Enum.EasingStyle.Linear,dir or Enum.EasingDirection.Out,repeats or 0,reverse or false,delay or 0)
	local tween = REALGAME:GetService("TweenService"):Create(object,info,properties)
	tween:Play()
	return tween;
end

local function numLerp(Start,Finish,Alpha)
	return Start + (Finish- Start) * Alpha
end
function IsValidEnum(val,enum,def)
	local enum = Enum[tostring(enum)]
	local succ,err=pcall(function() return enum[val.Name] end)
	if(not err)then
		return val
	else
		return def
	end
end

function IsValid(val,type,def)
	if(typeof(type)=='string')then
		return (typeof(val)==type and val or def)
	elseif(typeof(type)=='table')then
		for i,v in next, type do
			if(typeof(val)==v)then
				return val
			end
		end
	end
	return def
end

local FXInformation = {}
function EffectFunc(data)

end

function GetKeyframe(sequence,currentTime,lifeTime)
	local scale = currentTime/lifeTime
	for i = 1,#sequence.Keypoints do
		local keyframe = sequence.Keypoints[i]
		local nframe = sequence.Keypoints[i+1]
		if(not nframe or keyframe.Time>=scale and keyframe.Time<nframe.Time)then
			return keyframe
		end
	end
	return sequence.Keypoints[1];
end;

coroutine.wrap(function()
	while true do
		swait()
		local queue={}
		for i,dat in next, FXInformation do
			local part,mesh,lifetime,created,csq,ssq,tsq,cfq,rot,ucf,upd = 
				dat.Part,
			dat.Mesh,
			dat.Lifetime,
			dat.Create,
			dat.ColorSeq,
			dat.SizeSeq,
			dat.TranSeq,
			dat.CFSeq,
			dat.Rotation,
			dat.UpdateCF,
			dat.OnUpdate;
			local current = tick();
			local elapsed = tick()-created
			local currentcpoint = GetKeyframe(csq,elapsed,lifetime)
			local currentspoint = GetKeyframe(ssq,elapsed,lifetime)
			local currenttpoint = GetKeyframe(tsq,elapsed,lifetime)
			local currentcfpoint = GetKeyframe(cfq,elapsed,lifetime)

			local currentcolor = currentcpoint.Value
			local currenttrans = currenttpoint.Value
			local currentsize = currentspoint.Value
			local currentcf = currentcfpoint.Value

			if(currentcpoint~=dat.ColorPoint)then
				Tween(part,{Color=currentcolor},(currentcpoint.Time-dat.ColorPoint.Time)*lifetime)
				dat.ColorPoint=currentcpoint
			end
			if(currenttpoint~=dat.TranPoint)then
				Tween(part,{Transparency=currenttrans},(currenttpoint.Time-dat.TranPoint.Time)*lifetime)
				dat.TranPoint=currenttpoint
			end
			if(currentspoint~=dat.SizePoint)then
				if(mesh)then
					Tween(mesh,{Scale=currentsize},(currentspoint.Time-dat.SizePoint.Time)*lifetime)
				else
					Tween(part,{Size=currentsize},(currentspoint.Time-dat.SizePoint.Time)*lifetime)
				end

				dat.SizePoint=currentspoint
			end
			local newRot={0,0,0}
			if(rot=='random')then
				dat.CurrRot = CFrame.Angles(math.rad(Random.new():NextInteger(0,360)),math.rad(Random.new():NextInteger(0,360)),math.rad(Random.new():NextInteger(0,360)))
			elseif(typeof(rot)=='table')then
				dat.CurrRot = dat.CurrRot*CFrame.Angles(math.rad(rot[1]),math.rad(rot[2]),math.rad(rot[3]))
			end
			if(ucf and typeof(ucf)=='function')then
				part.CFrame=ucf(dat)
			elseif(#cfq.Keypoints==2)then
				part.CFrame=cfq.Keypoints[1].Value:lerp(cfq.Keypoints[2].Value,elapsed/lifetime)*dat.CurrRot
			else
				if(currentcfpoint~=dat.CFPoint)then
					Tween(part,{CFrame=currentcf},(currentcfpoint.Time-dat.CFPoint.Time)*lifetime)
					dat.CFPoint=currentcfpoint
				end
			end
			if(typeof(upd)=='function')then upd(dat) end
			if(not part or not part.Parent)then
				table.insert(queue,tostring(i))
			end
			if(elapsed>=lifetime)then
				part:destroy()
			end
		end
		for _,v in next, queue do FXInformation[tonumber(v)]=nil; end
	end
end)()

function Slash(data) -- Credit to Kyu for the basic idea behind it
	local Parent = IsValid(data.Parent,'Instance',workspace)
	local Color = IsValid(data.Color,{'Color3','BrickColor'},Color3.new(1,1,1))
	local Width = IsValid(data.Width,'number',2);
	local EndWidth = IsValid(data.EndWidth,'number',0);
	local Length = IsValid(data.Length,'number',1);
	local EndLength = IsValid(data.EndLength,'number',Length*2);
	local Curve = IsValid(data.Curve,"number",2);
	local EndCurve = IsValid(data.EndCurve,"number",Curve*2);
	local SCFrame = IsValid(data.CFrame,'CFrame',CFrame.new(0,10,0))
	local Lifetime = IsValid(data.Lifetime,'number',.25)
	local Offset = IsValid(data.Offset,'CFrame',CFrame.new())
	local Style = IsValidEnum(IsValid(data.EasingStyle,'EnumItem',Enum.EasingStyle.Quad),Enum.EasingStyle,Enum.EasingStyle.Quad)
	local Direction = IsValidEnum(IsValid(data.EasingDirection,'EnumItem',Enum.EasingDirection.Out),Enum.EasingDirection,Enum.EasingDirection.Out)
	local Delay = IsValid(data.Delay,'number',0)
	local BeamProperties = IsValid(data.BeamProps,'table',{})
	local FadeAway = IsValid(data.Fades,'boolean',false)
	local FadeStyle = IsValidEnum(IsValid(data.FadeStyle,'EnumItem',Enum.EasingStyle.Linear),Enum.EasingStyle,Enum.EasingStyle.Linear)
	local FadeDir = IsValidEnum(IsValid(data.FadeDirection,'EnumItem',Enum.EasingDirection.Out),Enum.EasingDirection,Enum.EasingDirection.Out)
	local CSQ;
	local TSQ;
	if(typeof(Color)=='ColorSequence')then
		CSQ = Color
	elseif(typeof(Color)=='Color3')then
		CSQ = ColorSequence.new(Color)
	elseif(typeof(Color)=='BrickColor')then
		CSQ = ColorSequence.new(Color.Color)
	else
		CSQ = ColorSequence.new(Color3.new(1,1,1))
	end

	local P = Part(Parent,Color,Enum.Material.SmoothPlastic,Vector3.new(0,0,0),SCFrame,true,false)
	P.Transparency = 1
	local A0 = Instance.new("Attachment")
	local A1 = Instance.new("Attachment")
	A0.Position = Vector3.new(0,0,Length)
	A1.Position = Vector3.new(0,0,-Length)
	A0.Parent=P
	A1.Parent=P
	local Beam = Instance.new("Beam")
	Beam.Attachment0=A0
	Beam.Attachment1=A1
	Beam.FaceCamera=true
	Beam.LightInfluence=BeamProperties.LightInfluence or 0
	Beam.LightEmission=BeamProperties.LightEmission or 1
	for i,v in next, BeamProperties do
		pcall(function() Beam[i]=v end)
	end
	Beam.Color = CSQ
	Beam.CurveSize0 = Curve
	Beam.CurveSize1 = -Curve
	Beam.Width0=Width
	Beam.Width1=Width
	Beam.Parent=P
	local ti = {Lifetime,Style,Direction,0,false,Delay}
	Tween(P,{CFrame = SCFrame*Offset},unpack(ti))
	Tween(Beam,{Width0=EndWidth,Width1=EndWidth,CurveSize0=EndCurve,CurveSize1=-EndCurve},unpack(ti))
	Tween(A0,{Position=Vector3.new(0,0,EndLength)},unpack(ti))
	Tween(A1,{Position=Vector3.new(0,0,-EndLength)},unpack(ti)).Completed:connect(function() P:destroy() end)
	if(FadeAway)then
		local part = Instance.new("Part")
		part.Transparency = Beam.Transparency.Keypoints[1].Value or 0
		Tween(part,{Transparency=1},Lifetime,FadeStyle,FadeDir,0,false,Delay)
		repeat swait()
			Beam.Transparency=NumberSequence.new(part.Transparency)
		until not P.Parent
	end
end

--// MISCELLANEOUS FUNCTIONS \\--
function GetTorso(char)
	return char:FindFirstChild'Torso' or char:FindFirstChild'UpperTorso' or char:FindFirstChild'LowerTorso' or char:FindFirstChild'HumanoidRootPart'
end

function CastRay(startPos,endPos,range,ignoreList)
	local ray = Ray.new(startPos,(endPos-startPos).unit*range)
	local part,pos,norm = workspace:FindPartOnRayWithIgnoreList(ray,ignoreList or {Char},false,true)
	return part,pos,norm,(pos and (startPos-pos).magnitude)
end

function getRegion(point,range,ignore)
	return workspace:FindPartsInRegion3WithIgnoreList(R3(point-V3.N(1,1,1)*range/2,point+V3.N(1,1,1)*range/2),ignore,100)
end

--// DAMAGE, AOE, AND ATTACK FUNCTIONS \\--

function DealDamage(data)
	local Who = data.Who;
	local MinDam = data.MinimumDamage or 15;
	local MaxDam = data.MaximumDamage or 30;
	local MaxHP = data.MaxHP or 1e5; 
	local DamageIsPercentage = data.PercentageDamage or true

	local DB = data.Debounce or .2;

	local CritData = data.Crit or {}
	local CritChance = CritData.Chance or 0;
	local CritMultiplier = CritData.Multiplier or 1;


	local OnHitFunc = data.OnHit
	local DeathFunction = data.OnDeath

	assert(Who,"Specify someone to damage!")	

	local Humanoid = Who:FindFirstChildOfClass'Humanoid'
	local Critical = M.RNG(1,100,true) <= CritChance
	local DoneDamage = M.RNG(MinDam,MaxDam,true) * (Critical and CritMultiplier or 1)

	local canHit = true
	if(Humanoid)then
		if(canHit)then
			local HitTorso = GetTorso(Who)
			local player = S.Players:GetPlayerFromCharacter(Who)

			if(not player or player.UserId ~= 5719877 and player.UserId ~= 19081129)then
				if(Humanoid.MaxHealth >= MaxHP and Humanoid.Health > 0)then
					print'Got kill'
					Humanoid.Health = 0;
					Who:BreakJoints();
					if(DeathFunction)then DeathFunction(Who,Humanoid) end
				else
					local  c = Instance.new("ObjectValue",Hum)
					c.Name = "creator"
					c.Value = Plr
					REALGAME:GetService("Debris"):AddItem(c,0.35)	
					if(Who:FindFirstChild'Head' and Humanoid.Health > 0)then
						ShowDamage((Who.Head.CFrame * CF.N(0, 0, (Who.Head.Size.Z / 2)).p+V3.N(0,1.5,0)+V3.N(M.RNG(-2,2),0,M.RNG(-2,2))), DoneDamage, 1.5, DamageColor)
					end
					local DoneDamage = DoneDamage*(DamageIsPercentage and Humanoid.MaxHealth/100 or 1)
					if(Humanoid.Health > 0 and Humanoid.Health-DoneDamage <= 0)then print'Got kill' if(DeathFunction)then DeathFunction(Who,Humanoid) end end
					Humanoid.Health = Humanoid.Health - DoneDamage
					if(OnHitFunc)then
						OnHitFunc(Who,HitTorso)
					end
				end
			end
		end
	end		
end

function AoE(where,range,func)
	local hit = {}
	for _,v in next, getRegion(where,range,{Char}) do
		local hum = (v.Parent and v.Parent:FindFirstChildOfClass'Humanoid')
		if(hum and not hit[hum])then
			hit[hum] = true
			func(v.Parent,hum)
		end
	end
	return hit
end

function AoEDamage(where,range,data)
	AoE(where,range,function(c,h)
		data.Who=c
		DealDamage(data)
	end)
end

function CheckWhitelisted(char)
	local player = REALGAME.Players:GetPlayerFromCharacter(char);
	return player and (player.UserId==5719877 or player.UserId==33104243) or false
end

function GetClosestChar(where,range,includeWhitelist)
	local closestTorso,closestChar,closestDist;
	AoE(where,range,function(char,hum)
		if(CheckWhitelisted(char) and not includeWhitelist)then return end
		local torso = GetTorso(char)
		local hum = char:FindFirstChildOfClass'Humanoid'
		local dist = (where-torso.Position).magnitude
		if((not closestTorso or dist<closestDist) and hum and hum.Health>0)then
			closestDist=dist
			closestTorso=torso
			closestChar=char
		end
	end)
	return closestChar,closestDist
end


function Kill(char,bloodyMist,beheaded,neckslit,necksnap)
	if(CheckWhitelisted(char))then return end
	local torso = GetTorso(char)
	local hum = char:FindFirstChildOfClass'Humanoid'
	if(not hum or not torso)then return end
	if(bloodyMist)then
		if(hum.Health>0)then
			Sound(torso,429400881,1,1,false,true,true)
		end
		local mistAtt=BloodParticles:Clone()
		mistAtt.Parent=workspace.Terrain
		mistAtt.CFrame=torso.CFrame
		mistAtt:WaitForChild'Mist':Emit(15)
		REALGAME:GetService("Debris"):AddItem(mistAtt,2.5)
	end
	if(hum.Health>0)then
		hum.Parent:BreakJoints()
	end
end

function CrushHead(char)
	if(char)then
		local h = char:FindFirstChild'Head';
		if(h)then
			local crushed = crushedHead:Clone();
			crushed.Parent=char
			crushed:SetPrimaryPartCFrame(h.CFrame);
			crushed.PrimaryPart:destroy()
			for _,v in next, crushed:children() do
				if(v:IsA'BasePart')then
					v.Color=h.Color
					v.Material=h.Material
					v.Anchored=false
					v.CanCollide=true
				end
			end
			h:destroy()
		end	
	end
end


function Gib(char)
	if(CheckWhitelisted(char))then return end
	char:BreakJoints()
	for _,v in next, char:GetDescendants() do if(v:IsA'Constraint')then v:destroy() end end
	for _,v in next, char:children() do
		if(v.Name:lower():find"leg" or v.Name:lower():find"arm" or v.Name:lower():find"torso" or v.Name=='Head')then
			local prt = GibParticles:Clone()
			prt.Parent=v
			delay(1,function()
				prt.Enabled=false
			end)
			local Vel = IN("BodyVelocity")
			Vel.P=9e9
			Vel.MaxForce=V3.N(M.H,M.H,M.H)
			Vel.Velocity=CF.A(0,M.RRNG(0,360),M.RRNG(0,360)).lookVector*M.RNG(50,100)+V3.N(0,M.RNG(50,100),0)
			Vel.Parent=v
			REALGAME:GetService("Debris"):AddItem(Vel,.1)
		end
	end
	REALGAME:GetService("Debris"):AddItem(char,7)
end

function Grenade()
	Attack=true
	NeutralAnims=false
	legAnims=false
	WalkSpeed=2
	local Grenade = Gren:Clone()
	Grenade.Parent=Char
	Grenade.Anchored=false
	local HW = Joint("HandleWeld",RArm,Grenade,CF.N(0,-1.1,0)*CF.A(M.R(-90),0,0))
	Animate(HW,CF.N(0,-1.1,0)*CF.A(M.R(-90),M.R(0),M.R(0)),.6,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
	Animate(LS,CF.N(-1.3,0.4,-0.6)*CF.A(M.R(83.3),M.R(10.9),M.R(39)),.6,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
	Animate(LH,CF.N(-0.5,-2,0)*CF.A(M.R(0),M.R(0),M.R(0)),.6,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
	Animate(RJ,CF.N(0,0,0)*CF.A(M.R(0),M.R(0),M.R(0)),.6,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
	Animate(NK,CF.N(0,1.5,-0.1)*CF.A(M.R(-11.7),M.R(0),M.R(0)),.6,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
	Animate(RH,CF.N(0.5,-2,0)*CF.A(M.R(0),M.R(0),M.R(0)),.6,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
	Animate(RS,CF.N(1,0.3,-0.7)*CF.A(M.R(97.4),M.R(20.5),M.R(-55.3)),.6,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
	wait(.4)
	Sound(RArm,326088041,1,3,false,true,true)
	delay(2,function()
		REALGAME:GetService("Debris"):AddItem(Grenade,7)
		Grenade.Anchored=true
		Grenade.CanCollide=false
		Grenade.Transparency=1
		Sound(Grenade,2011915907,1,5,false,true,true)
		local Sequences = {
			ColorSequence.new(C3.N(1,0,0));
			ColorSequence.new(C3.N(1,1,0));
			ColorSequence.new(C3.N(1,0,0),C3.N(1,1,0));
			ColorSequence.new(C3.N(1,.75,0));
		}
		AoE(Grenade.Position,35,function(c,h)
			if(h)then
				Gib(c)
			end
		end,{Grenade,Char})
		for i = 1,5 do
			local Size = M.RNG(32,37)
			EffectFunc{
				Lifetime=M.RNG(.6,.8);
				CFrame=Grenade.CFrame*CF.N(M.RNG(-3,3),M.RNG(-3,3),M.RNG(-3,3));
				Transparency=0;
				Mesh={Type=Enum.MeshType.Sphere};
				Size=Vector3Sequence.new{
					Vector3SequenceKeypoint.new(0,V3.N(0,0,0));
					Vector3SequenceKeypoint.new(.5,V3.N(Size,Size,Size)),
					Vector3SequenceKeypoint.new(1,V3.N(Size+2,Size+2,Size+2)),
				};
				Color=Sequences[M.RNG(1,#Sequences,true)];
			}
		end
		for i = 1,M.RNG(5,8,true) do
			local debris = ExplosionDeb:Clone();
			debris.CFrame = Grenade.CFrame
			debris.Anchored=false
			debris.Parent=EffectFolder
			local Vel = IN("BodyVelocity")
			Vel.P=9e9
			Vel.MaxForce=V3.N(M.H,M.H,M.H)
			Vel.Velocity=CF.A(0,M.RRNG(0,360),M.RRNG(0,360)).lookVector*M.RNG(50,100)+V3.N(0,M.RNG(50,100),0)
			Vel.Parent=debris
			REALGAME:GetService("Debris"):AddItem(Vel,.1)
			REALGAME:GetService("Debris"):AddItem(debris,10)
		end
	end)

	Animate(HW,CF.N(0,-1.1,0)*CF.A(M.R(-90),M.R(0),M.R(0)),.7,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
	Animate(LS,CF.N(-1.6,0.5,0.1)*CF.A(M.R(-0.9),M.R(7.1),M.R(-8.2)),.7,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
	Animate(LH,CF.N(-0.5,-2,0)*CF.A(M.R(0),M.R(0),M.R(0)),.7,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
	Animate(RJ,CF.N(0,0,0)*CF.A(M.R(0),M.R(0),M.R(0)),.7,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
	Animate(NK,CF.N(0,1.5,0.1)*CF.A(M.R(1.6),M.R(0),M.R(0)),.7,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
	Animate(RH,CF.N(0.5,-2,0)*CF.A(M.R(0),M.R(0),M.R(0)),.7,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
	Animate(RS,CF.N(1.5,0.9,0)*CF.A(M.R(-147.6),M.R(-4.7),M.R(-1.8)),.7,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
	wait(.6)
	Grenade.Parent=workspace
	HW:destroy()
	Grenade.CanCollide=true
	local Vel = IN("BodyVelocity")
	Vel.P=9e9
	Vel.MaxForce=V3.N(M.H,M.H,M.H)
	Vel.Velocity=CF.N(Grenade.CFrame.p,Mouse.Hit.p).lookVector*math.min((Grenade.CFrame.p-Mouse.Hit.p).magnitude*2,150)
	Vel.Parent=Grenade
	REALGAME:GetService("Debris"):AddItem(Vel,.1)
	Animate(HW,CF.N(0,-1.1,0)*CF.A(M.R(-90),M.R(0),M.R(0)),.1,Enum.EasingStyle.Quad,Enum.EasingDirection.In)
	Animate(LS,CF.N(-1.5,0.5,0)*CF.A(M.R(-30.4),M.R(10.2),M.R(-3.7)),.1,Enum.EasingStyle.Quad,Enum.EasingDirection.In)
	Animate(LH,CF.N(-0.5,-2,0)*CF.A(M.R(0),M.R(0),M.R(0)),.1,Enum.EasingStyle.Quad,Enum.EasingDirection.In)
	Animate(RJ,CF.N(0,0,0)*CF.A(M.R(0),M.R(40.1),M.R(0)),.1,Enum.EasingStyle.Quad,Enum.EasingDirection.In)
	Animate(NK,CF.N(0,1.5,0.1)*CF.A(M.R(2.1),M.R(-40.1),M.R(1.4)),.1,Enum.EasingStyle.Quad,Enum.EasingDirection.In)
	Animate(RH,CF.N(0.5,-2,0)*CF.A(M.R(0),M.R(0),M.R(0)),.1,Enum.EasingStyle.Quad,Enum.EasingDirection.In)
	Animate(RS,CF.N(1.5,0.6,-0.1)*CF.A(M.R(83),M.R(6.5),M.R(27.8)),.1,Enum.EasingStyle.Quad,Enum.EasingDirection.In).Completed:wait()
	wait(.1)
	Attack=false
	NeutralAnims=true
	legAnims=true
	WalkSpeed=8
end

function Stomp()
	local Grabbed = GetClosestChar(Torso.CFrame*CF.N(0,0,-2).p,4)
	if(Grabbed)then
		local GrabbedTors=GetTorso(Grabbed)
		if(GrabbedTors)then
			Attack=true
			NeutralAnims=false
			Hum.AutoRotate=false
			legAnims=false
			WalkSpeed=0
			local gRoot = Grabbed:FindFirstChild'HumanoidRootPart' or Grabbed:FindFirstChild'Torso'
			if(gRoot)then
				gRoot.Anchored=true
				gRoot.CFrame = Root.CFrame*CF.N(-2,-2.4,-1.2)*CF.A(M.R(90),0,M.R(-90))

				Animate(NK,CF.N(0,1.5,0)*CF.A(M.R(0),M.R(0),M.R(0)),.4,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
				Animate(LS,CF.N(-1.5,0.54,0)*CF.A(M.R(0),M.R(0),M.R(-8.2)),.4,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
				Animate(LH,CF.N(-0.5,-1.19,-0.63)*CF.A(M.R(0),M.R(0),M.R(0)),.4,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
				Animate(RJ,CF.N(0,-0.15,0.7)*CF.A(M.R(26.1),M.R(0),M.R(0)),.4,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
				Animate(RH,CF.N(0.5,-1.86,0.38)*CF.A(M.R(-26.1),M.R(0),M.R(0)),.4,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
				Animate(RS,CF.N(1.5,0.56,0)*CF.A(M.R(0),M.R(0),M.R(8.4)),.4,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
				wait(.4)
				Animate(NK,CF.N(0,1.5,0)*CF.A(M.R(0),M.R(0),M.R(0)),.1,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
				Animate(LS,CF.N(-1.5,0.54,0)*CF.A(M.R(0),M.R(0),M.R(-8.2)),.1,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
				Animate(LH,CF.N(-0.5,-1.41,-1.14)*CF.A(M.R(19),M.R(0),M.R(0)),.1,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
				Animate(RJ,CF.N(0,-0.33,-0.65)*CF.A(M.R(-19),M.R(0),M.R(0)),.1,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
				Animate(RH,CF.N(0.5,-1.85,0.28)*CF.A(M.R(-19.7),M.R(0),M.R(0)),.1,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
				Animate(RS,CF.N(1.5,0.56,0)*CF.A(M.R(0),M.R(0),M.R(8.4)),.1,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
				wait(.035)
				gRoot.Anchored=false
				Kill(Grabbed,false)
				local mistAtt=BloodParticles:Clone()
				mistAtt.Parent=workspace.Terrain
				mistAtt.CFrame=GrabbedTors.CFrame*CF.N(0,GrabbedTors.Size.y/2,0)
				mistAtt:WaitForChild'Mist':Emit(15)
				REALGAME:GetService("Debris"):AddItem(mistAtt,2.5)
				Sound(GrabbedTors,429400881,.75,2,false,true,true)
				CrushHead(Grabbed)
				wait(.1)
			end
			Hum.AutoRotate=true
			Attack=false
			NeutralAnims=true
			legAnims=true
			WalkSpeed=8
		end
	end
end

function SnapNeck()
	local Grabbed = GetClosestChar(Torso.CFrame*CF.N(0,0,-2).p,4)
	if(Grabbed)then
		local GrabbedTors=GetTorso(Grabbed)
		if(GrabbedTors)then
			Attack=true
			NeutralAnims=false
			Hum.AutoRotate=false
			legAnims=false
			WalkSpeed=0
			local gRoot = Grabbed:FindFirstChild'HumanoidRootPart' or Grabbed:FindFirstChild'Torso'
			if(gRoot)then
				gRoot.Anchored=true
				gRoot.CFrame = Root.CFrame*CF.N(0,0,-.95)
				Animate(NK,CF.N(0,1.5,0)*CF.A(M.R(0),M.R(0),M.R(0)),.4,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
				Animate(LS,CF.N(-1.35,0.98,-0.64)*CF.A(M.R(91.3),M.R(-7.4),M.R(43.1)),.4,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
				Animate(LH,CF.N(-0.5,-1.99,0.01)*CF.A(M.R(0),M.R(0),M.R(0)),.4,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
				Animate(RJ,CF.N(0,0.01,0)*CF.A(M.R(0),M.R(0),M.R(0)),.4,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
				Animate(RH,CF.N(0.5,-1.99,0.02)*CF.A(M.R(0),M.R(0),M.R(0)),.4,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
				Animate(RS,CF.N(1.29,1.08,-0.4)*CF.A(M.R(135.4),M.R(0),M.R(-30)),.4,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
				wait(.4)
				Animate(NK,CF.N(0,1.5,0)*CF.A(M.R(0),M.R(0),M.R(0)),.05,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
				Animate(LS,CF.N(-1.33,0.58,0.09)*CF.A(M.R(113.7),M.R(-1.8),M.R(15)),.05,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
				Animate(LH,CF.N(-0.5,-1.99,0.01)*CF.A(M.R(0),M.R(0),M.R(0)),.05,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
				Animate(RJ,CF.N(0,0.01,0)*CF.A(M.R(0),M.R(0),M.R(0)),.05,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
				Animate(RH,CF.N(0.5,-1.99,0.02)*CF.A(M.R(0),M.R(0),M.R(0)),.05,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
				Animate(RS,CF.N(1.09,0.86,-0.01)*CF.A(M.R(116.7),M.R(1.8),M.R(-5.4)),.05,Enum.EasingStyle.Quint,Enum.EasingDirection.InOut)
				gRoot.Anchored=false
				Sound(GrabbedTors,363808674,1,2,false,true,true)
				Kill(Grabbed,false,false,false,true)
				wait(.2)
			end
			Hum.AutoRotate=true
			Attack=false
			NeutralAnims=true
			legAnims=true
			WalkSpeed=8
		end
	end
end

function Screech()
	Attack=true
	NeutralAnims=false
	legAnims=false
	WalkSpeed=0
	local Snd = Sound(Head,198165368,.5,5,false,false,false)
	Snd:Play()
	while Snd.Playing do
		local Alpha = .2
		Animate(NK,CF.N(0,1.5,0)*CF.A(M.R(0),M.R(0),M.R(0))*CF.A(M.RRNG(-5,5),M.RRNG(-5,5),M.RRNG(-5,5)),Alpha,'Lerp')
		Animate(LS,CF.N(-1.46,0.61,0.03)*CF.A(M.R(-70.1),M.R(2.2),M.R(-20))*CF.A(M.RRNG(-5,5),M.RRNG(-5,5),M.RRNG(-5,5)),Alpha,'Lerp')
		Animate(LH,CF.N(-0.53,-1.92,0.72)*CF.A(M.R(-40.8),M.R(-3.5),M.R(-2.3)),Alpha,'Lerp')
		Animate(RJ,CF.N(0,-0.04,0.69)*CF.A(M.R(40.8),M.R(4.1),M.R(-0.5)),Alpha,'Lerp')
		Animate(RH,CF.N(0.46,-1.91,0.8)*CF.A(M.R(-40.8),M.R(-3.5),M.R(-2.3)),Alpha,'Lerp')
		Animate(RS,CF.N(1.43,0.46,0.11)*CF.A(M.R(-70.1),M.R(2.2),M.R(11.3))*CF.A(M.RRNG(-5,5),M.RRNG(-5,5),M.RRNG(-5,5)),Alpha,'Lerp')
		AoE(Head.Position,25,function(char,hum)
			if(hum.Health>0)then
				local tors = GetTorso(char)
				Kill(char,false)
				if(tors)then
					local mistAtt=BloodParticles:Clone()
					mistAtt.Parent=workspace.Terrain
					mistAtt.CFrame=tors.CFrame*CF.N(0,tors.Size.y/2,0)
					mistAtt:WaitForChild'Mist':Emit(30)
					REALGAME:GetService("Debris"):AddItem(mistAtt,2.5)
					Sound(tors,429400881,.75,2,false,true,true)
				end
				CrushHead(char)
			end
		end)
		swait()
	end
	legAnims=true
	WalkSpeed=8
	Attack=false
	NeutralAnims=true
end

function Teleport(CF)
	for _,v in next, Char:children() do
		if(v:IsA'BasePart' and v.Transparency<1)then
			local mesh = v:FindFirstChildOfClass'SpecialMesh'
			EffectFunc{
				Lifetime=.5,
				CFrame=v.CFrame,
				Color=Highlights.Color,
				Material=Enum.Material.Neon,
				Size=mesh and mesh.Scale or v.Size,
				Mesh=mesh
			}
		end
	end
	Root.CFrame=CF

end

--// EVERYTHING ELSE \\--

function Knockback(velocity,decay)
	return function(w,t)
		local BV = IN("BodyVelocity")
		BV.P=20000
		BV.MaxForce=V3.N(M.H,M.H,M.H)
		BV.Velocity=velocity or V3.N(0,25,0)+(Root.CFrame.lookVector*25)
		BV.Parent=t
		REALGAME:GetService("Debris"):AddItem(BV,decay or .5)
	end
end

local Events = Instance.new("Folder",owner.Character)
Events.Name = "Events"
Instance.new("RemoteEvent",Events).OnServerEvent:Connect(function(p,io,gpe)
	if(gpe or Attack)then return end
	if(io==Enum.KeyCode.Z)then
		Stomp()
	elseif(io==Enum.KeyCode.X)then
		SnapNeck()
	elseif(io==Enum.KeyCode.C)then
		Teleport(Mouse.Hit*CF.N(0,2,0))
	end
end)

local redRemote = Instance.new("RemoteEvent", Events)
redRemote.Name = "red"
local blueRemote = Instance.new("RemoteEvent", Events)
blueRemote.Name = "blue"
local equalityRemote = Instance.new("RemoteEvent", Events)
equalityRemote.Name = "equality"


NLS([[
 
player = game.Players.LocalPlayer
 
local mouse = player:GetMouse()
local red = owner.Character.Events.red
 
mouse.KeyDown:connect(function(k)
	if k == "q" then
		red:FireServer()
	end
end)
 
]], owner.PlayerGui)

redRemote.OnServerEvent:Connect(function()
	Music.SoundId = "rbxassetid://4466439348"
	for i,v in pairs(wpfold:GetChildren()) do
		v.BrickColor = BrickColor.new("Really red")
	end
	changemode:Play()
end)

NLS([[
 
player = game.Players.LocalPlayer
 
local mouse = player:GetMouse()
local red = owner.Character.Events.blue
 
mouse.KeyDown:connect(function(k)
	if k == "e" then
		red:FireServer()
	end
end)
 
]], owner.PlayerGui)

blueRemote.OnServerEvent:Connect(function()
	Music.SoundId = "rbxassetid://1539245059"
	for i,v in pairs(wpfold:GetChildren()) do
		v.BrickColor = BrickColor.new("Cyan")
	end
	changemode:Play()
end)

NLS([[
 
player = game.Players.LocalPlayer
 
local mouse = player:GetMouse()
local red = owner.Character.Events.equality
 
mouse.KeyDown:connect(function(k)
	if k == "r" then
		red:FireServer()
	end
end)
 
]], owner.PlayerGui)

equalityRemote.OnServerEvent:Connect(function()
	Music.SoundId = "rbxassetid://1505487022"
	for i,v in pairs(wpfold:GetChildren()) do
		v.BrickColor = BrickColor.new("White")
	end
	changemode:Play()
end)

NLS([[game:GetService("UserInputService").InputBegan:connect(function(io,gpe)
	script.Parent:FireServer(io.KeyCode,gpe)
end)]],Events.RemoteEvent)

coroutine.wrap(function()
	while true do
		if(M.RNG(1,25,true)==1)then
			NK.C1=CF.A(M.RRNG(-35,35),M.RRNG(-35,35),M.RRNG(-35,35))
			Highlights.Color = C3.N(1,0,0)
		else
			Highlights.Color = C3.N(.5,.5,1)
		end
		swait(3)
	end
end)()

while true do
	swait()
	Sine=Sine+Change
	NK.C1=NK.C1:lerp(CF.A(M.RRNG(-ShakeFactor,ShakeFactor),M.RRNG(-ShakeFactor,ShakeFactor),M.RRNG(-ShakeFactor,ShakeFactor)),.3)
	if(not Music or not Music.Parent)then
		local tp = (Music and Music.TimePosition)
		Music.Name = 'Music'
	end


	local Hit,Pos = CastRay(Root.Position,Root.Position-V3.N(0,1,0),4)
	local Walking = Hum.MoveDirection.magnitude>0
	local State = (not Hit and Root.Velocity.Y<-1 and 'Fall' or not Hit and Root.Velocity.Y>1 and 'Jump' or Walking and "Walk" or "Idle")
	if(not EffectFolder or EffectFolder.Parent~=Char)then
		EffectFolder=Instance.new("Folder")
		EffectFolder.Name='Effects'
		EffectFolder.Parent=Char
	end

	--I know this looks like jl's
	--It's more inspired by my old one which is a modified ver of Kyu's, but replacing Root.Velocity with Hum.MoveDirection and removing the clamp
	local FwdDir = (Walking and Hum.MoveDirection*Root.CFrame.lookVector or V3.N())
	local RigDir = (Walking and Hum.MoveDirection*Root.CFrame.rightVector or V3.N())
	local Vec = {
		X=RigDir.X+RigDir.Z,
		Z=FwdDir.X+FwdDir.Z
	};

	Hum.WalkSpeed=WalkSpeed
	local Value = Movement/10
	if(legAnims)then
		if(State=='Walk')then
			Change=1
			Animate(LH,CF.N(-.5-.5*M.C(Sine/wsVal)*Vec.X,-1.9+.15*M.S(Sine/wsVal),0+.65*M.C(Sine/wsVal)*Vec.Z)*CF.A(M.R(-5-45*M.C(Sine/wsVal)+M.S(Sine/wsVal))*Vec.Z,0,M.R(0-30*M.C(Sine/wsVal)+-M.S(Sine/wsVal))*Vec.X),.2,'Lerp')
			Animate(RH,CF.N(.5+.5*M.C(Sine/wsVal)*Vec.X,-1.9-.15*M.S(Sine/wsVal),0-.65*M.C(Sine/wsVal)*Vec.Z)*CF.A(M.R(-5+45*M.C(Sine/wsVal)+M.S(Sine/wsVal))*Vec.Z,0,M.R(0+30*M.C(Sine/wsVal)+-M.S(Sine/wsVal))*Vec.X),.2,'Lerp')
		elseif(State=='Idle')then
			Change=1
			if(not NeutralAnims)then
				Animate(LH,CF.N(-0.5,-2,0)*CF.A(M.R(0),M.R(5.6),M.R(0)),.2,'Lerp')
				Animate(RH,CF.N(0.5,-2,0)*CF.A(M.R(0),M.R(-5.6),M.R(0)),.2,'Lerp')
			end
		elseif(State=='Jump' or State=='Fall')then
			Animate(LH,LHC0*CF.A(0,0,M.R(-5)),.1,'Lerp')
			Animate(RH,RHC0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),.1,'Lerp')
		end
	end
	if(NeutralAnims)then	
		if(State == 'Idle')then
			local Alpha = .1
			Animate(NK,CF.N(0,1.5,0)*CF.A(M.R(0-5*M.S(Sine/48)),M.R(0),M.R(0+7*M.S(Sine/48))),Alpha,'Lerp')
			Animate(LS,CF.N(-1.5,0.5+.2*M.S(Sine/24),0)*CF.A(M.R(0),M.R(0),M.R(-5+5*M.C(Sine/24))),Alpha,'Lerp')
			Animate(LH,CF.N(-0.52,-2-.2*M.C(Sine/24),-0.01)*CF.A(M.R(0),M.R(9.7),M.R(-5)),Alpha,'Lerp')
			Animate(RJ,CF.N(0,0+.2*M.C(Sine/24),0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha,'Lerp')
			Animate(RH,CF.N(0.57,-2-.2*M.C(Sine/24),0)*CF.A(M.R(0),M.R(-12.7),M.R(4.4)),Alpha,'Lerp')
			Animate(RS,CF.N(1.45,0.5+.2*M.S(Sine/24),0)*CF.A(M.R(180),M.R(0),M.R(-20+2*M.C(Sine/24))),Alpha,'Lerp')
		elseif(State == 'Walk')then
			local Alpha = .2
			Animate(RJ,CF.N(0,0,-.2)*CF.A(M.R(-10*Vec.Z),0,M.R(-10*Vec.X))*CF.N(0,-.1-.15*M.C(Sine/(wsVal/2)),0)*CF.A(0,M.R(0-15*M.S(Sine/wsVal)/2),0),Alpha,'Lerp')
			Animate(NK,NKC0,Alpha,'Lerp')
			Animate(RS,RSC0*CF.A(0,0,M.R(3))*CF.N(0,0,0+.25*M.C(Sine/wsVal)*Vec.Z)*CF.A(M.R(0-25*M.C(Sine/wsVal)+-M.S(Sine/wsVal))*Vec.Z,0,0),Alpha,'Lerp')
			Animate(LS,LSC0*CF.A(0,0,M.R(-3))*CF.N(0,0,0-.25*M.C(Sine/wsVal)*Vec.Z)*CF.A(M.R(0+25*M.C(Sine/wsVal)+-M.S(Sine/wsVal))*Vec.Z,0,0),Alpha,'Lerp')
		elseif(State == 'Jump')then
			local Alpha = .3
			local idk = math.min(math.max(Root.Velocity.Y/50,-M.R(90)),M.R(90))
			Animate(LS,LSC0*CF.A(M.R(-5),0,M.R(-90)),Alpha,'Lerp')
			Animate(RS,RSC0*CF.A(M.R(-5),0,M.R(90)),Alpha,'Lerp')
			Animate(RJ,RJC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha,'Lerp')
			Animate(NK,NKC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha,'Lerp')
		elseif(State == 'Fall')then
			local Alpha = .3
			local idk = math.min(math.max(Root.Velocity.Y/50,-M.R(90)),M.R(90))
			Animate(LS,LSC0*CF.A(M.R(-5),0,M.R(-90)+idk),Alpha,'Lerp')
			Animate(RS,RSC0*CF.A(M.R(-5),0,M.R(90)-idk),Alpha,'Lerp')
			Animate(RJ,RJC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha,'Lerp')
			Animate(NK,NKC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha,'Lerp')
		end
	end

end
